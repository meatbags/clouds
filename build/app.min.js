var clouds =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/config.js":
/*!**********************!*\
  !*** ./js/config.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Global config. */\n\nconst Config = {\n  width: 100,\n  height: 75\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Config);\n\n//# sourceURL=webpack://clouds/./js/config.js?");

/***/ }),

/***/ "./js/lib/glsl/CopyShader.js":
/*!***********************************!*\
  !*** ./js/lib/glsl/CopyShader.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Full-screen textured quad shader\r\n */\n\nTHREE.CopyShader = {\n\n\t\tuniforms: {\n\n\t\t\t\t\"tDiffuse\": { value: null },\n\t\t\t\t\"opacity\": { value: 1.0 }\n\n\t\t},\n\n\t\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\t\tfragmentShader: [\"uniform float opacity;\", \"uniform sampler2D tDiffuse;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"gl_FragColor = opacity * texel;\", \"}\"].join(\"\\n\")\n\n};\n\n//# sourceURL=webpack://clouds/./js/lib/glsl/CopyShader.js?");

/***/ }),

/***/ "./js/lib/glsl/EffectComposer.js":
/*!***************************************!*\
  !*** ./js/lib/glsl/EffectComposer.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.EffectComposer = function (renderer, renderTarget) {\n\n\tthis.renderer = renderer;\n\n\tif (renderTarget === undefined) {\n\n\t\tvar parameters = {\n\t\t\tminFilter: THREE.LinearFilter,\n\t\t\tmagFilter: THREE.LinearFilter,\n\t\t\tformat: THREE.RGBAFormat,\n\t\t\tstencilBuffer: false\n\t\t};\n\n\t\tvar size = renderer.getDrawingBufferSize(new THREE.Vector2());\n\t\trenderTarget = new THREE.WebGLRenderTarget(size.width, size.height, parameters);\n\t\trenderTarget.texture.name = 'EffectComposer.rt1';\n\t}\n\n\tthis.renderTarget1 = renderTarget;\n\tthis.renderTarget2 = renderTarget.clone();\n\tthis.renderTarget2.texture.name = 'EffectComposer.rt2';\n\n\tthis.writeBuffer = this.renderTarget1;\n\tthis.readBuffer = this.renderTarget2;\n\n\tthis.renderToScreen = true;\n\n\tthis.passes = [];\n\n\t// dependencies\n\n\tif (THREE.CopyShader === undefined) {\n\n\t\tconsole.error('THREE.EffectComposer relies on THREE.CopyShader');\n\t}\n\n\tif (THREE.ShaderPass === undefined) {\n\n\t\tconsole.error('THREE.EffectComposer relies on THREE.ShaderPass');\n\t}\n\n\tthis.copyPass = new THREE.ShaderPass(THREE.CopyShader);\n\n\tthis._previousFrameTime = Date.now();\n};\n\nObject.assign(THREE.EffectComposer.prototype, {\n\n\tswapBuffers: function () {\n\n\t\tvar tmp = this.readBuffer;\n\t\tthis.readBuffer = this.writeBuffer;\n\t\tthis.writeBuffer = tmp;\n\t},\n\n\taddPass: function (pass) {\n\n\t\tthis.passes.push(pass);\n\n\t\tvar size = this.renderer.getDrawingBufferSize(new THREE.Vector2());\n\t\tpass.setSize(size.width, size.height);\n\t},\n\n\tinsertPass: function (pass, index) {\n\n\t\tthis.passes.splice(index, 0, pass);\n\t},\n\n\tisLastEnabledPass: function (passIndex) {\n\n\t\tfor (var i = passIndex + 1; i < this.passes.length; i++) {\n\n\t\t\tif (this.passes[i].enabled) {\n\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t},\n\n\trender: function (deltaTime) {\n\n\t\t// deltaTime value is in seconds\n\n\t\tif (deltaTime === undefined) {\n\n\t\t\tdeltaTime = (Date.now() - this._previousFrameTime) * 0.001;\n\t\t}\n\n\t\tthis._previousFrameTime = Date.now();\n\n\t\tvar currentRenderTarget = this.renderer.getRenderTarget();\n\n\t\tvar maskActive = false;\n\n\t\tvar pass,\n\t\t    i,\n\t\t    il = this.passes.length;\n\n\t\tfor (i = 0; i < il; i++) {\n\n\t\t\tpass = this.passes[i];\n\n\t\t\tif (pass.enabled === false) continue;\n\n\t\t\tpass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);\n\t\t\tpass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);\n\n\t\t\tif (pass.needsSwap) {\n\n\t\t\t\tif (maskActive) {\n\n\t\t\t\t\tvar context = this.renderer.context;\n\n\t\t\t\t\tcontext.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);\n\n\t\t\t\t\tthis.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);\n\n\t\t\t\t\tcontext.stencilFunc(context.EQUAL, 1, 0xffffffff);\n\t\t\t\t}\n\n\t\t\t\tthis.swapBuffers();\n\t\t\t}\n\n\t\t\tif (THREE.MaskPass !== undefined) {\n\n\t\t\t\tif (pass instanceof THREE.MaskPass) {\n\n\t\t\t\t\tmaskActive = true;\n\t\t\t\t} else if (pass instanceof THREE.ClearMaskPass) {\n\n\t\t\t\t\tmaskActive = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.renderer.setRenderTarget(currentRenderTarget);\n\t},\n\n\treset: function (renderTarget) {\n\n\t\tif (renderTarget === undefined) {\n\n\t\t\tvar size = this.renderer.getDrawingBufferSize(new THREE.Vector2());\n\n\t\t\trenderTarget = this.renderTarget1.clone();\n\t\t\trenderTarget.setSize(size.width, size.height);\n\t\t}\n\n\t\tthis.renderTarget1.dispose();\n\t\tthis.renderTarget2.dispose();\n\t\tthis.renderTarget1 = renderTarget;\n\t\tthis.renderTarget2 = renderTarget.clone();\n\n\t\tthis.writeBuffer = this.renderTarget1;\n\t\tthis.readBuffer = this.renderTarget2;\n\t},\n\n\tsetSize: function (width, height) {\n\n\t\tthis.renderTarget1.setSize(width, height);\n\t\tthis.renderTarget2.setSize(width, height);\n\n\t\tfor (var i = 0; i < this.passes.length; i++) {\n\n\t\t\tthis.passes[i].setSize(width, height);\n\t\t}\n\t}\n\n});\n\nTHREE.Pass = function () {\n\n\t// if set to true, the pass is processed by the composer\n\tthis.enabled = true;\n\n\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\tthis.needsSwap = true;\n\n\t// if set to true, the pass clears its buffer before rendering\n\tthis.clear = false;\n\n\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\tthis.renderToScreen = false;\n};\n\nObject.assign(THREE.Pass.prototype, {\n\n\tsetSize: function (width, height) {},\n\n\trender: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n\n\t\tconsole.error('THREE.Pass: .render() must be implemented in derived pass.');\n\t}\n\n});\n\n// Helper for passes that need to fill the viewport with a single quad.\nTHREE.Pass.FullScreenQuad = function () {\n\n\tvar camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\tvar geometry = new THREE.PlaneBufferGeometry(2, 2);\n\n\tvar FullScreenQuad = function (material) {\n\n\t\tthis._mesh = new THREE.Mesh(geometry, material);\n\t};\n\n\tObject.defineProperty(FullScreenQuad.prototype, 'material', {\n\n\t\tget: function () {\n\n\t\t\treturn this._mesh.material;\n\t\t},\n\n\t\tset: function (value) {\n\n\t\t\tthis._mesh.material = value;\n\t\t}\n\n\t});\n\n\tObject.assign(FullScreenQuad.prototype, {\n\n\t\trender: function (renderer) {\n\n\t\t\trenderer.render(this._mesh, camera);\n\t\t}\n\n\t});\n\n\treturn FullScreenQuad;\n}();\n\n//# sourceURL=webpack://clouds/./js/lib/glsl/EffectComposer.js?");

/***/ }),

/***/ "./js/lib/glsl/LuminosityHighPassShader.js":
/*!*************************************************!*\
  !*** ./js/lib/glsl/LuminosityHighPassShader.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author bhouston / http://clara.io/\r\n *\r\n * Luminosity\r\n * http://en.wikipedia.org/wiki/Luminosity\r\n */\n\nTHREE.LuminosityHighPassShader = {\n\n\t\tshaderID: \"luminosityHighPass\",\n\n\t\tuniforms: {\n\n\t\t\t\t\"tDiffuse\": { type: \"t\", value: null },\n\t\t\t\t\"luminosityThreshold\": { type: \"f\", value: 1.0 },\n\t\t\t\t\"smoothWidth\": { type: \"f\", value: 1.0 },\n\t\t\t\t\"defaultColor\": { type: \"c\", value: new THREE.Color(0x000000) },\n\t\t\t\t\"defaultOpacity\": { type: \"f\", value: 0.0 }\n\n\t\t},\n\n\t\tvertexShader: [\"varying vec2 vUv;\", \"void main() {\", \"vUv = uv;\", \"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\", \"}\"].join(\"\\n\"),\n\n\t\tfragmentShader: [\"uniform sampler2D tDiffuse;\", \"uniform vec3 defaultColor;\", \"uniform float defaultOpacity;\", \"uniform float luminosityThreshold;\", \"uniform float smoothWidth;\", \"varying vec2 vUv;\", \"void main() {\", \"vec4 texel = texture2D( tDiffuse, vUv );\", \"vec3 luma = vec3( 0.299, 0.587, 0.114 );\", \"float v = dot( texel.xyz, luma );\", \"vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\", \"float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\", \"gl_FragColor = mix( outputColor, texel, alpha );\", \"}\"].join(\"\\n\")\n\n};\n\n//# sourceURL=webpack://clouds/./js/lib/glsl/LuminosityHighPassShader.js?");

/***/ }),

/***/ "./js/lib/glsl/RenderPass.js":
/*!***********************************!*\
  !*** ./js/lib/glsl/RenderPass.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.RenderPass = function (scene, camera, overrideMaterial, clearColor, clearAlpha) {\n\n\t\tTHREE.Pass.call(this);\n\n\t\tthis.scene = scene;\n\t\tthis.camera = camera;\n\n\t\tthis.overrideMaterial = overrideMaterial;\n\n\t\tthis.clearColor = clearColor;\n\t\tthis.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;\n\n\t\tthis.clear = true;\n\t\tthis.clearDepth = false;\n\t\tthis.needsSwap = false;\n};\n\nTHREE.RenderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n\n\t\tconstructor: THREE.RenderPass,\n\n\t\trender: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n\n\t\t\t\tvar oldAutoClear = renderer.autoClear;\n\t\t\t\trenderer.autoClear = false;\n\n\t\t\t\tthis.scene.overrideMaterial = this.overrideMaterial;\n\n\t\t\t\tvar oldClearColor, oldClearAlpha;\n\n\t\t\t\tif (this.clearColor) {\n\n\t\t\t\t\t\toldClearColor = renderer.getClearColor().getHex();\n\t\t\t\t\t\toldClearAlpha = renderer.getClearAlpha();\n\n\t\t\t\t\t\trenderer.setClearColor(this.clearColor, this.clearAlpha);\n\t\t\t\t}\n\n\t\t\t\tif (this.clearDepth) {\n\n\t\t\t\t\t\trenderer.clearDepth();\n\t\t\t\t}\n\n\t\t\t\trenderer.setRenderTarget(this.renderToScreen ? null : readBuffer);\n\n\t\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\t\tif (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n\t\t\t\trenderer.render(this.scene, this.camera);\n\n\t\t\t\tif (this.clearColor) {\n\n\t\t\t\t\t\trenderer.setClearColor(oldClearColor, oldClearAlpha);\n\t\t\t\t}\n\n\t\t\t\tthis.scene.overrideMaterial = null;\n\t\t\t\trenderer.autoClear = oldAutoClear;\n\t\t}\n\n});\n\n//# sourceURL=webpack://clouds/./js/lib/glsl/RenderPass.js?");

/***/ }),

/***/ "./js/lib/glsl/ShaderPass.js":
/*!***********************************!*\
  !*** ./js/lib/glsl/ShaderPass.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\n\nTHREE.ShaderPass = function (shader, textureID) {\n\n\t\tTHREE.Pass.call(this);\n\n\t\tthis.textureID = textureID !== undefined ? textureID : \"tDiffuse\";\n\n\t\tif (shader instanceof THREE.ShaderMaterial) {\n\n\t\t\t\tthis.uniforms = shader.uniforms;\n\n\t\t\t\tthis.material = shader;\n\t\t} else if (shader) {\n\n\t\t\t\tthis.uniforms = THREE.UniformsUtils.clone(shader.uniforms);\n\n\t\t\t\tthis.material = new THREE.ShaderMaterial({\n\n\t\t\t\t\t\tdefines: Object.assign({}, shader.defines),\n\t\t\t\t\t\tuniforms: this.uniforms,\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\n\n\t\t\t\t});\n\t\t}\n\n\t\tthis.fsQuad = new THREE.Pass.FullScreenQuad(this.material);\n};\n\nTHREE.ShaderPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n\n\t\tconstructor: THREE.ShaderPass,\n\n\t\trender: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n\n\t\t\t\tif (this.uniforms[this.textureID]) {\n\n\t\t\t\t\t\tthis.uniforms[this.textureID].value = readBuffer.texture;\n\t\t\t\t}\n\n\t\t\t\tthis.fsQuad.material = this.material;\n\n\t\t\t\tif (this.renderToScreen) {\n\n\t\t\t\t\t\trenderer.setRenderTarget(null);\n\t\t\t\t\t\tthis.fsQuad.render(renderer);\n\t\t\t\t} else {\n\n\t\t\t\t\t\trenderer.setRenderTarget(writeBuffer);\n\t\t\t\t\t\t// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600\n\t\t\t\t\t\tif (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n\t\t\t\t\t\tthis.fsQuad.render(renderer);\n\t\t\t\t}\n\t\t}\n\n});\n\n//# sourceURL=webpack://clouds/./js/lib/glsl/ShaderPass.js?");

/***/ }),

/***/ "./js/lib/glsl/SkyShader.js":
/*!**********************************!*\
  !*** ./js/lib/glsl/SkyShader.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author zz85 / https://github.com/zz85\r\n *\r\n * Based on \"A Practical Analytic Model for Daylight\"\r\n * aka The Preetham Model, the de facto standard analytic skydome model\r\n * http://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf\r\n *\r\n * First implemented by Simon Wallner\r\n * http://www.simonwallner.at/projects/atmospheric-scattering\r\n *\r\n * Improved by Martin Upitis\r\n * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR\r\n *\r\n * Three.js integration by zz85 http://twitter.com/blurspline\r\n*/\n\nTHREE.Sky = function () {\n\t\tvar shader = THREE.Sky.SkyShader;\n\t\tvar material = new THREE.ShaderMaterial({\n\t\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\t\tvertexShader: shader.vertexShader,\n\t\t\t\tuniforms: THREE.UniformsUtils.clone(shader.uniforms),\n\t\t\t\tside: THREE.BackSide\n\t\t});\n\t\tTHREE.Mesh.call(this, new THREE.BoxBufferGeometry(1, 1, 1), material);\n};\n\nTHREE.Sky.prototype = Object.create(THREE.Mesh.prototype);\nTHREE.Sky.SkyShader = {\n\t\tuniforms: {\n\t\t\t\tluminance: { value: 1 },\n\t\t\t\tturbidity: { value: 11.7 },\n\t\t\t\trayleigh: { value: 2 },\n\t\t\t\tmieCoefficient: { value: 0.005 },\n\t\t\t\tmieDirectionalG: { value: 0.8 },\n\t\t\t\tsunPosition: { value: new THREE.Vector3() }\n\t\t},\n\n\t\tvertexShader: ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'const vec3 up = vec3( 0.0, 1.0, 0.0 );',\n\n\t\t// constants for atmospheric scattering\n\t\t'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;',\n\n\t\t// wavelength of used primaries, according to preetham\n\t\t'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );',\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\t'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );',\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\t'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );',\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\t'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );',\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\t'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '\tfloat c = ( 0.2 * T ) * 10E-18;', '\treturn 0.434 * c * MieConst;', '}', 'void main() {', '\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '\tvWorldPosition = worldPosition.xyz;', '\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '\tgl_Position.z = gl_Position.w;', // set z to camera.far\n\n\t\t'\tvSunDirection = normalize( sunPosition );', '\tvSunE = sunIntensity( dot( vSunDirection, up ) );', '\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );',\n\n\t\t// extinction (absorbtion + out scattering)\n\t\t// rayleigh coefficients\n\t\t'\tvBetaR = totalRayleigh * rayleighCoefficient;',\n\n\t\t// mie coefficients\n\t\t'\tvBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\\n'),\n\n\t\tfragmentShader: ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float luminance;', 'uniform float mieDirectionalG;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );',\n\n\t\t// constants for atmospheric scattering\n\t\t'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air\n\t\t'const float N = 2.545E25;', // number of molecules per unit volume for air at\n\t\t// 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\t'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', 'const vec3 up = vec3( 0.0, 1.0, 0.0 );',\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\t'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;',\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\t'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;',\n\t\t// 1.0 / ( 4.0 * pi )\n\t\t'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '\tfloat g2 = pow( g, 2.0 );', '\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}',\n\n\t\t// Filmic ToneMapping http://filmicgames.com/archives/75\n\t\t'const float A = 0.15;', 'const float B = 0.50;', 'const float C = 0.10;', 'const float D = 0.20;', 'const float E = 0.02;', 'const float F = 0.30;', 'const float whiteScale = 1.0748724675633854;', // 1.0 / Uncharted2Tonemap(1000.0)\n\n\t\t'vec3 Uncharted2Tonemap( vec3 x ) {', '\treturn ((x * (A * x + C * B) + D * E) / (x * (A * x + B) + D * F)) - E / F;', '}', 'void main() {',\n\t\t// optical length\n\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t'\tfloat zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );', '\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '\tfloat sR = rayleighZenithLength * inverse;', '\tfloat sM = mieZenithLength * inverse;',\n\n\t\t// combined extinction factor\n\t\t'\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );',\n\n\t\t// in scattering\n\t\t'\tfloat cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );', '\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '\tvec3 betaRTheta = vBetaR * rPhase;', '\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );', '\tvec3 betaMTheta = vBetaM * mPhase;', '\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '\tLin *= mix(vec3(1.0), pow(vSunE * ((betaRTheta + betaMTheta) / (vBetaR + vBetaM)) * Fex, vec3(1.0 / 2.0)), clamp(pow(1.0 - 10.0 * dot(up, vSunDirection), 5.0), 0.0, 1.0));',\n\n\t\t// nightsky\n\t\t'\tvec3 direction = normalize( vWorldPosition - cameraPos );', '\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]', '\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]', '\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '\tvec3 L0 = vec3( 0.1 ) * Fex;',\n\n\t\t// composition + solar disc\n\t\t//'\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );',\n\t\t//'\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;',\n\n\t\t//'\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );',\n\t\t//'\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );',\n\t\t'\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.001 );', '\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );',\n\t\t//'\tvec3 color = curr; * whiteScale;',\n\t\t'\tvec3 retColor = pow( curr * 0.9, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '\tgl_FragColor = vec4( retColor, 1.0 );', '}'].join('\\n')\n\n};\n\n//# sourceURL=webpack://clouds/./js/lib/glsl/SkyShader.js?");

/***/ }),

/***/ "./js/lib/glsl/UnrealBloomPass.js":
/*!****************************************!*\
  !*** ./js/lib/glsl/UnrealBloomPass.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author spidersharma / http://eduperiment.com/\r\n *\r\n * Inspired from Unreal Engine\r\n * https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\r\n */\nTHREE.UnrealBloomPass = function (resolution, strength, radius, threshold) {\n\n\tTHREE.Pass.call(this);\n\n\tthis.strength = strength !== undefined ? strength : 1;\n\tthis.radius = radius;\n\tthis.threshold = threshold;\n\tthis.resolution = resolution !== undefined ? new THREE.Vector2(resolution.x, resolution.y) : new THREE.Vector2(256, 256);\n\n\t// create color only once here, reuse it later inside the render function\n\tthis.clearColor = new THREE.Color(0, 0, 0);\n\n\t// render targets\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat };\n\tthis.renderTargetsHorizontal = [];\n\tthis.renderTargetsVertical = [];\n\tthis.nMips = 5;\n\tvar resx = Math.round(this.resolution.x / 2);\n\tvar resy = Math.round(this.resolution.y / 2);\n\n\tthis.renderTargetBright = new THREE.WebGLRenderTarget(resx, resy, pars);\n\tthis.renderTargetBright.texture.name = \"UnrealBloomPass.bright\";\n\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\tvar renderTargetHorizonal = new THREE.WebGLRenderTarget(resx, resy, pars);\n\n\t\trenderTargetHorizonal.texture.name = \"UnrealBloomPass.h\" + i;\n\t\trenderTargetHorizonal.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsHorizontal.push(renderTargetHorizonal);\n\n\t\tvar renderTargetVertical = new THREE.WebGLRenderTarget(resx, resy, pars);\n\n\t\trenderTargetVertical.texture.name = \"UnrealBloomPass.v\" + i;\n\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\tthis.renderTargetsVertical.push(renderTargetVertical);\n\n\t\tresx = Math.round(resx / 2);\n\n\t\tresy = Math.round(resy / 2);\n\t}\n\n\t// luminosity high pass material\n\n\tif (THREE.LuminosityHighPassShader === undefined) console.error(\"THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader\");\n\n\tvar highPassShader = THREE.LuminosityHighPassShader;\n\tthis.highPassUniforms = THREE.UniformsUtils.clone(highPassShader.uniforms);\n\n\tthis.highPassUniforms[\"luminosityThreshold\"].value = threshold;\n\tthis.highPassUniforms[\"smoothWidth\"].value = 0.01;\n\n\tthis.materialHighPassFilter = new THREE.ShaderMaterial({\n\t\tuniforms: this.highPassUniforms,\n\t\tvertexShader: highPassShader.vertexShader,\n\t\tfragmentShader: highPassShader.fragmentShader,\n\t\tdefines: {}\n\t});\n\n\t// Gaussian Blur Materials\n\tthis.separableBlurMaterials = [];\n\tvar kernelSizeArray = [3, 5, 7, 9, 11];\n\tvar resx = Math.round(this.resolution.x / 2);\n\tvar resy = Math.round(this.resolution.y / 2);\n\n\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\tthis.separableBlurMaterials.push(this.getSeperableBlurMaterial(kernelSizeArray[i]));\n\n\t\tthis.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\tresx = Math.round(resx / 2);\n\n\t\tresy = Math.round(resy / 2);\n\t}\n\n\t// Composite material\n\tthis.compositeMaterial = this.getCompositeMaterial(this.nMips);\n\tthis.compositeMaterial.uniforms[\"blurTexture1\"].value = this.renderTargetsVertical[0].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture2\"].value = this.renderTargetsVertical[1].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture3\"].value = this.renderTargetsVertical[2].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture4\"].value = this.renderTargetsVertical[3].texture;\n\tthis.compositeMaterial.uniforms[\"blurTexture5\"].value = this.renderTargetsVertical[4].texture;\n\tthis.compositeMaterial.uniforms[\"bloomStrength\"].value = strength;\n\tthis.compositeMaterial.uniforms[\"bloomRadius\"].value = 0.1;\n\tthis.compositeMaterial.needsUpdate = true;\n\n\tvar bloomFactors = [1.0, 0.8, 0.6, 0.4, 0.2];\n\tthis.compositeMaterial.uniforms[\"bloomFactors\"].value = bloomFactors;\n\tthis.bloomTintColors = [new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1), new THREE.Vector3(1, 1, 1)];\n\tthis.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n\n\t// copy material\n\tif (THREE.CopyShader === undefined) {\n\n\t\tconsole.error(\"THREE.BloomPass relies on THREE.CopyShader\");\n\t}\n\n\tvar copyShader = THREE.CopyShader;\n\n\tthis.copyUniforms = THREE.UniformsUtils.clone(copyShader.uniforms);\n\tthis.copyUniforms[\"opacity\"].value = 1.0;\n\n\tthis.materialCopy = new THREE.ShaderMaterial({\n\t\tuniforms: this.copyUniforms,\n\t\tvertexShader: copyShader.vertexShader,\n\t\tfragmentShader: copyShader.fragmentShader,\n\t\tblending: THREE.AdditiveBlending,\n\t\tdepthTest: false,\n\t\tdepthWrite: false,\n\t\ttransparent: true\n\t});\n\n\tthis.enabled = true;\n\tthis.needsSwap = false;\n\n\tthis.oldClearColor = new THREE.Color();\n\tthis.oldClearAlpha = 1;\n\n\tthis.basic = new THREE.MeshBasicMaterial();\n\n\tthis.fsQuad = new THREE.Pass.FullScreenQuad(null);\n};\n\nTHREE.UnrealBloomPass.prototype = Object.assign(Object.create(THREE.Pass.prototype), {\n\n\tconstructor: THREE.UnrealBloomPass,\n\n\tdispose: function () {\n\n\t\tfor (var i = 0; i < this.renderTargetsHorizontal.length; i++) {\n\n\t\t\tthis.renderTargetsHorizontal[i].dispose();\n\t\t}\n\n\t\tfor (var i = 0; i < this.renderTargetsVertical.length; i++) {\n\n\t\t\tthis.renderTargetsVertical[i].dispose();\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\t},\n\n\tsetSize: function (width, height) {\n\n\t\tvar resx = Math.round(width / 2);\n\t\tvar resy = Math.round(height / 2);\n\n\t\tthis.renderTargetBright.setSize(resx, resy);\n\n\t\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\t\tthis.renderTargetsHorizontal[i].setSize(resx, resy);\n\t\t\tthis.renderTargetsVertical[i].setSize(resx, resy);\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"texSize\"].value = new THREE.Vector2(resx, resy);\n\n\t\t\tresx = Math.round(resx / 2);\n\t\t\tresy = Math.round(resy / 2);\n\t\t}\n\t},\n\n\trender: function (renderer, writeBuffer, readBuffer, deltaTime, maskActive) {\n\n\t\tthis.oldClearColor.copy(renderer.getClearColor());\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tvar oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor(this.clearColor, 0);\n\n\t\tif (maskActive) renderer.context.disable(renderer.context.STENCIL_TEST);\n\n\t\t// Render input to screen\n\n\t\tif (this.renderToScreen) {\n\n\t\t\tthis.fsQuad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget(null);\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render(renderer);\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[\"tDiffuse\"].value = readBuffer.texture;\n\t\tthis.highPassUniforms[\"luminosityThreshold\"].value = this.threshold;\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget(this.renderTargetBright);\n\t\trenderer.clear();\n\t\tthis.fsQuad.render(renderer);\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tvar inputRenderTarget = this.renderTargetBright;\n\n\t\tfor (var i = 0; i < this.nMips; i++) {\n\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[i];\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget(this.renderTargetsHorizontal[i]);\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render(renderer);\n\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"colorTexture\"].value = this.renderTargetsHorizontal[i].texture;\n\t\t\tthis.separableBlurMaterials[i].uniforms[\"direction\"].value = THREE.UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget(this.renderTargetsVertical[i]);\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render(renderer);\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[i];\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[\"bloomStrength\"].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[\"bloomRadius\"].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[\"bloomTintColors\"].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget(this.renderTargetsHorizontal[0]);\n\t\trenderer.clear();\n\t\tthis.fsQuad.render(renderer);\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.fsQuad.material = this.materialCopy;\n\t\tthis.copyUniforms[\"tDiffuse\"].value = this.renderTargetsHorizontal[0].texture;\n\n\t\tif (maskActive) renderer.context.enable(renderer.context.STENCIL_TEST);\n\n\t\tif (this.renderToScreen) {\n\n\t\t\trenderer.setRenderTarget(null);\n\t\t\tthis.fsQuad.render(renderer);\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget(readBuffer);\n\t\t\tthis.fsQuad.render(renderer);\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor(this.oldClearColor, this.oldClearAlpha);\n\t\trenderer.autoClear = oldAutoClear;\n\t},\n\n\tgetSeperableBlurMaterial: function (kernelRadius) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"KERNEL_RADIUS\": kernelRadius,\n\t\t\t\t\"SIGMA\": kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"colorTexture\": { value: null },\n\t\t\t\t\"texSize\": { value: new THREE.Vector2(0.5, 0.5) },\n\t\t\t\t\"direction\": { value: new THREE.Vector2(0.5, 0.5) }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"#include <common>\\\r\n\t\t\t\tvarying vec2 vUv;\\n\\\r\n\t\t\t\tuniform sampler2D colorTexture;\\n\\\r\n\t\t\t\tuniform vec2 texSize;\\\r\n\t\t\t\tuniform vec2 direction;\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\\\r\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\\\r\n\t\t\t\t}\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\\\r\n\t\t\t\t\tfloat fSigma = float(SIGMA);\\\r\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\\\r\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\\\r\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\\\r\n\t\t\t\t\t\tfloat x = float(i);\\\r\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\\\r\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\\\r\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\\\r\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\\\r\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\\\r\n\t\t\t\t\t\tweightSum += 2.0 * w;\\\r\n\t\t\t\t\t}\\\r\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\\n\\\r\n\t\t\t\t}\"\n\t\t});\n\t},\n\n\tgetCompositeMaterial: function (nMips) {\n\n\t\treturn new THREE.ShaderMaterial({\n\n\t\t\tdefines: {\n\t\t\t\t\"NUM_MIPS\": nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t\"blurTexture1\": { value: null },\n\t\t\t\t\"blurTexture2\": { value: null },\n\t\t\t\t\"blurTexture3\": { value: null },\n\t\t\t\t\"blurTexture4\": { value: null },\n\t\t\t\t\"blurTexture5\": { value: null },\n\t\t\t\t\"dirtTexture\": { value: null },\n\t\t\t\t\"bloomStrength\": { value: 1.0 },\n\t\t\t\t\"bloomFactors\": { value: null },\n\t\t\t\t\"bloomTintColors\": { value: null },\n\t\t\t\t\"bloomRadius\": { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader: \"varying vec2 vUv;\\n\\\r\n\t\t\t\tvoid main() {\\n\\\r\n\t\t\t\t\tvUv = uv;\\n\\\r\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n\\\r\n\t\t\t\t}\",\n\n\t\t\tfragmentShader: \"varying vec2 vUv;\\\r\n\t\t\t\tuniform sampler2D blurTexture1;\\\r\n\t\t\t\tuniform sampler2D blurTexture2;\\\r\n\t\t\t\tuniform sampler2D blurTexture3;\\\r\n\t\t\t\tuniform sampler2D blurTexture4;\\\r\n\t\t\t\tuniform sampler2D blurTexture5;\\\r\n\t\t\t\tuniform sampler2D dirtTexture;\\\r\n\t\t\t\tuniform float bloomStrength;\\\r\n\t\t\t\tuniform float bloomRadius;\\\r\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\\\r\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\\\r\n\t\t\t\t\\\r\n\t\t\t\tfloat lerpBloomFactor(const in float factor) { \\\r\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\\\r\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\\\r\n\t\t\t\t}\\\r\n\t\t\t\t\\\r\n\t\t\t\tvoid main() {\\\r\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \\\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\\\r\n\t\t\t\t}\"\n\t\t});\n\t}\n\n});\n\nTHREE.UnrealBloomPass.BlurDirectionX = new THREE.Vector2(1.0, 0.0);\nTHREE.UnrealBloomPass.BlurDirectionY = new THREE.Vector2(0.0, 1.0);\n\n//# sourceURL=webpack://clouds/./js/lib/glsl/UnrealBloomPass.js?");

/***/ }),

/***/ "./js/lib/glsl/index.js":
/*!******************************!*\
  !*** ./js/lib/glsl/index.js ***!
  \******************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _CopyShader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CopyShader.js */ \"./js/lib/glsl/CopyShader.js\");\n/* harmony import */ var _CopyShader_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_CopyShader_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _EffectComposer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./EffectComposer.js */ \"./js/lib/glsl/EffectComposer.js\");\n/* harmony import */ var _EffectComposer_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_EffectComposer_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./LuminosityHighPassShader.js */ \"./js/lib/glsl/LuminosityHighPassShader.js\");\n/* harmony import */ var _LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_LuminosityHighPassShader_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _RenderPass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RenderPass.js */ \"./js/lib/glsl/RenderPass.js\");\n/* harmony import */ var _RenderPass_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_RenderPass_js__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _ShaderPass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ShaderPass.js */ \"./js/lib/glsl/ShaderPass.js\");\n/* harmony import */ var _ShaderPass_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_ShaderPass_js__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./UnrealBloomPass.js */ \"./js/lib/glsl/UnrealBloomPass.js\");\n/* harmony import */ var _UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n\n\n\n//import './SkyShader.js';\n//import './Poster.js'\n\n//# sourceURL=webpack://clouds/./js/lib/glsl/index.js?");

/***/ }),

/***/ "./js/lib/loaders/FBXLoader.js":
/*!*************************************!*\
  !*** ./js/lib/loaders/FBXLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author Kyle-Larson https://github.com/Kyle-Larson\r\n * @author Takahiro https://github.com/takahirox\r\n * @author Lewy Blue https://github.com/looeee\r\n *\r\n * Loader loads FBX file and generates Group representing FBX scene.\r\n * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format\r\n * Versions lower than this may load but will probably have errors\r\n *\r\n * Needs Support:\r\n *  Morph normals / blend shape normals\r\n *\r\n * FBX format references:\r\n * \thttps://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure\r\n * \thttp://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)\r\n *\r\n * \tBinary format specification:\r\n *\t\thttps://code.blender.org/2013/08/fbx-binary-file-format-specification/\r\n *\r\n * @author meatbags\r\n *    fixes for Maya 2019\r\n *    ctrl+f \"meatbags\" for changes\r\n */\n\nTHREE.FBXLoader = function () {\n\n\t\t\tvar fbxTree;\n\t\t\tvar connections;\n\t\t\tvar sceneGraph;\n\n\t\t\tfunction FBXLoader(manager) {\n\t\t\t\t\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\t\t\t}\n\n\t\t\tFBXLoader.prototype = {\n\t\t\t\t\t\tconstructor: FBXLoader,\n\t\t\t\t\t\tcrossOrigin: 'anonymous',\n\t\t\t\t\t\tload: function (url, onLoad, onProgress, onError) {\n\t\t\t\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\t\t\t\tvar path = self.path === undefined ? THREE.LoaderUtils.extractUrlBase(url) : self.path;\n\t\t\t\t\t\t\t\t\tvar loader = new THREE.FileLoader(this.manager);\n\t\t\t\t\t\t\t\t\tloader.setPath(self.path);\n\t\t\t\t\t\t\t\t\tloader.setResponseType('arraybuffer');\n\t\t\t\t\t\t\t\t\tloader.load(url, function (buffer) {\n\t\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonLoad(self.parse(buffer, path));\n\t\t\t\t\t\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (onError) onError(error);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself.manager.itemError(url);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}, 0);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, onProgress, onError);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetPath: function (value) {\n\t\t\t\t\t\t\t\t\tthis.path = value;\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetResourcePath: function (value) {\n\t\t\t\t\t\t\t\t\tthis.resourcePath = value;\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetCrossOrigin: function (value) {\n\t\t\t\t\t\t\t\t\tthis.crossOrigin = value;\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tparse: function (FBXBuffer, path) {\n\t\t\t\t\t\t\t\t\tif (isFbxFormatBinary(FBXBuffer)) {\n\t\t\t\t\t\t\t\t\t\t\t\tfbxTree = new BinaryParser().parse(FBXBuffer);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tvar FBXText = convertArrayBufferToString(FBXBuffer);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!isFbxFormatASCII(FBXText)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('THREE.FBXLoader: Unknown format.');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (getFbxVersion(FBXText) < 7000) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tfbxTree = new TextParser().parse(FBXText);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// console.log( fbxTree );\n\n\t\t\t\t\t\t\t\t\tvar textureLoader = new THREE.TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);\n\n\t\t\t\t\t\t\t\t\treturn new FBXTreeParser(textureLoader).parse(fbxTree);\n\t\t\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t// Parse the FBXTree object returned by the BinaryParser or TextParser and return a THREE.Group\n\t\t\tfunction FBXTreeParser(textureLoader) {\n\n\t\t\t\t\t\tthis.textureLoader = textureLoader;\n\t\t\t}\n\n\t\t\tFBXTreeParser.prototype = {\n\n\t\t\t\t\t\tconstructor: FBXTreeParser,\n\n\t\t\t\t\t\tparse: function () {\n\n\t\t\t\t\t\t\t\t\tconnections = this.parseConnections();\n\n\t\t\t\t\t\t\t\t\tvar images = this.parseImages();\n\t\t\t\t\t\t\t\t\tvar textures = this.parseTextures(images);\n\t\t\t\t\t\t\t\t\tvar materials = this.parseMaterials(textures);\n\t\t\t\t\t\t\t\t\tvar deformers = this.parseDeformers();\n\t\t\t\t\t\t\t\t\tvar geometryMap = new GeometryParser().parse(deformers);\n\n\t\t\t\t\t\t\t\t\tthis.parseScene(deformers, geometryMap, materials);\n\n\t\t\t\t\t\t\t\t\treturn sceneGraph;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )\n\t\t\t\t\t\t// and details the connection type\n\t\t\t\t\t\tparseConnections: function () {\n\n\t\t\t\t\t\t\t\t\tvar connectionMap = new Map();\n\n\t\t\t\t\t\t\t\t\tif ('Connections' in fbxTree) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar rawConnections = fbxTree.Connections.connections;\n\n\t\t\t\t\t\t\t\t\t\t\t\trawConnections.forEach(function (rawConnection) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar fromID = rawConnection[0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar toID = rawConnection[1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar relationship = rawConnection[2];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!connectionMap.has(fromID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconnectionMap.set(fromID, {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar parentRelationship = { ID: toID, relationship: relationship };\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconnectionMap.get(fromID).parents.push(parentRelationship);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!connectionMap.has(toID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconnectionMap.set(toID, {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparents: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchildren: []\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar childRelationship = { ID: fromID, relationship: relationship };\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconnectionMap.get(toID).children.push(childRelationship);\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn connectionMap;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse FBXTree.Objects.Video for embedded image data\n\t\t\t\t\t\t// These images are connected to textures in FBXTree.Objects.Textures\n\t\t\t\t\t\t// via FBXTree.Connections.\n\t\t\t\t\t\tparseImages: function () {\n\n\t\t\t\t\t\t\t\t\tvar images = {};\n\t\t\t\t\t\t\t\t\tvar blobs = {};\n\n\t\t\t\t\t\t\t\t\tif ('Video' in fbxTree.Objects) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar videoNodes = fbxTree.Objects.Video;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var nodeID in videoNodes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar videoNode = videoNodes[nodeID];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar id = parseInt(nodeID);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\timages[id] = videoNode.RelativeFilename || videoNode.Filename;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// raw image data is in videoNode.Content\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ('Content' in videoNode) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (arrayBufferContent || base64Content) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar image = this.parseImage(videoNodes[nodeID]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tblobs[videoNode.RelativeFilename || videoNode.Filename] = image;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tfor (var id in images) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar filename = images[id];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (blobs[filename] !== undefined) images[id] = blobs[filename];else images[id] = images[id].split('\\\\').pop();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn images;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse embedded image data in FBXTree.Video.Content\n\t\t\t\t\t\tparseImage: function (videoNode) {\n\n\t\t\t\t\t\t\t\t\tvar content = videoNode.Content;\n\t\t\t\t\t\t\t\t\tvar fileName = videoNode.RelativeFilename || videoNode.Filename;\n\t\t\t\t\t\t\t\t\tvar extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();\n\n\t\t\t\t\t\t\t\t\tvar type;\n\n\t\t\t\t\t\t\t\t\tswitch (extension) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'bmp':\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype = 'image/bmp';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'jpg':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'jpeg':\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype = 'image/jpeg';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'png':\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype = 'image/png';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'tif':\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype = 'image/tiff';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'tga':\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (typeof THREE.TGALoader !== 'function') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('FBXLoader: THREE.TGALoader is required to load TGA textures');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (THREE.Loader.Handlers.get('.tga') === null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar tgaLoader = new THREE.TGALoader();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttgaLoader.setPath(this.textureLoader.path);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTHREE.Loader.Handlers.add(/\\.tga$/i, tgaLoader);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype = 'image/tga';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('FBXLoader: Image type \"' + extension + '\" is not supported.');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (typeof content === 'string') {\n\t\t\t\t\t\t\t\t\t\t\t\t// ASCII format\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn 'data:' + type + ';base64,' + content;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t// Binary Format\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar array = new Uint8Array(content);\n\t\t\t\t\t\t\t\t\t\t\t\treturn window.URL.createObjectURL(new Blob([array], { type: type }));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse nodes in FBXTree.Objects.Texture\n\t\t\t\t\t\t// These contain details such as UV scaling, cropping, rotation etc and are connected\n\t\t\t\t\t\t// to images in FBXTree.Objects.Video\n\t\t\t\t\t\tparseTextures: function (images) {\n\n\t\t\t\t\t\t\t\t\tvar textureMap = new Map();\n\n\t\t\t\t\t\t\t\t\tif ('Texture' in fbxTree.Objects) {\n\t\t\t\t\t\t\t\t\t\t\t\tvar textureNodes = fbxTree.Objects.Texture;\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var nodeID in textureNodes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// meatbags: fix relative filename problem\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar filename = textureNodes[nodeID].RelativeFilename;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (filename.indexOf('..\\\\') == -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar texture = this.parseTexture(textureNodes[nodeID], images);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttextureMap.set(parseInt(nodeID), texture);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttextureMap.set(parseInt(nodeID), null);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// end changes\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn textureMap;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse individual node in FBXTree.Objects.Texture\n\t\t\t\t\t\tparseTexture: function (textureNode, images) {\n\n\t\t\t\t\t\t\t\t\tvar texture = this.loadTexture(textureNode, images);\n\t\t\t\t\t\t\t\t\ttexture.ID = textureNode.id;\n\t\t\t\t\t\t\t\t\ttexture.name = textureNode.attrName;\n\t\t\t\t\t\t\t\t\tvar wrapModeU = textureNode.WrapModeU;\n\t\t\t\t\t\t\t\t\tvar wrapModeV = textureNode.WrapModeV;\n\t\t\t\t\t\t\t\t\tvar valueU = wrapModeU !== undefined ? wrapModeU.value : 0;\n\t\t\t\t\t\t\t\t\tvar valueV = wrapModeV !== undefined ? wrapModeV.value : 0;\n\n\t\t\t\t\t\t\t\t\t// http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a\n\t\t\t\t\t\t\t\t\t// 0: repeat(default), 1: clamp\n\n\t\t\t\t\t\t\t\t\ttexture.wrapS = valueU === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\t\t\t\t\t\t\t\t\ttexture.wrapT = valueV === 0 ? THREE.RepeatWrapping : THREE.ClampToEdgeWrapping;\n\n\t\t\t\t\t\t\t\t\tif ('Scaling' in textureNode) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar values = textureNode.Scaling.value;\n\n\t\t\t\t\t\t\t\t\t\t\t\ttexture.repeat.x = values[0];\n\t\t\t\t\t\t\t\t\t\t\t\ttexture.repeat.y = values[1];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn texture;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// load a texture specified as a blob or data URI, or via an external URL using THREE.TextureLoader\n\t\t\t\t\t\tloadTexture: function (textureNode, images) {\n\n\t\t\t\t\t\t\t\t\tvar fileName;\n\t\t\t\t\t\t\t\t\tvar currentPath = this.textureLoader.path;\n\t\t\t\t\t\t\t\t\tvar children = connections.get(textureNode.id).children;\n\t\t\t\t\t\t\t\t\tif (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfileName = images[children[0].ID];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.textureLoader.setPath(undefined);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tvar texture;\n\t\t\t\t\t\t\t\t\tvar extension = textureNode.FileName.slice(-3).toLowerCase();\n\t\t\t\t\t\t\t\t\tif (extension === 'tga') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar loader = THREE.Loader.Handlers.get('.tga');\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (loader === null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('FBXLoader: TGALoader not found, creating empty placeholder texture for', fileName);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttexture = new THREE.Texture();\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttexture = loader.load(fileName);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (extension === 'psd') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('FBXLoader: PSD textures are not supported, creating empty placeholder texture for', fileName);\n\t\t\t\t\t\t\t\t\t\t\t\ttexture = new THREE.Texture();\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttexture = this.textureLoader.load(fileName);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tthis.textureLoader.setPath(currentPath);\n\n\t\t\t\t\t\t\t\t\treturn texture;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse nodes in FBXTree.Objects.Material\n\t\t\t\t\t\tparseMaterials: function (textureMap) {\n\n\t\t\t\t\t\t\t\t\tvar materialMap = new Map();\n\n\t\t\t\t\t\t\t\t\tif ('Material' in fbxTree.Objects) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar materialNodes = fbxTree.Objects.Material;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var nodeID in materialNodes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar material = this.parseMaterial(materialNodes[nodeID], textureMap);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (material !== null) materialMap.set(parseInt(nodeID), material);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn materialMap;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse single node in FBXTree.Objects.Material\n\t\t\t\t\t\t// Materials are connected to texture maps in FBXTree.Objects.Textures\n\t\t\t\t\t\t// FBX format currently only supports Lambert and Phong shading models\n\t\t\t\t\t\tparseMaterial: function (materialNode, textureMap) {\n\n\t\t\t\t\t\t\t\t\tvar ID = materialNode.id;\n\t\t\t\t\t\t\t\t\tvar name = materialNode.attrName;\n\t\t\t\t\t\t\t\t\tvar type = materialNode.ShadingModel;\n\n\t\t\t\t\t\t\t\t\t// Case where FBX wraps shading model in property object.\n\t\t\t\t\t\t\t\t\tif (typeof type === 'object') {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttype = type.value;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Ignore unused materials which don't have any connections.\n\t\t\t\t\t\t\t\t\tif (!connections.has(ID)) return null;\n\n\t\t\t\t\t\t\t\t\tvar parameters = this.parseParameters(materialNode, textureMap, ID);\n\n\t\t\t\t\t\t\t\t\tvar material;\n\n\t\t\t\t\t\t\t\t\tswitch (type.toLowerCase()) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// meatbags: add Stringray PBR -> standard material support\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'unknown':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.MeshStandardMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t// end changes\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'phong':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'lambert':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.MeshLambertMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: unknown material type \"%s\". Defaulting to MeshPhongMaterial.', type);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tmaterial.setValues(parameters);\n\t\t\t\t\t\t\t\t\tmaterial.name = name;\n\n\t\t\t\t\t\t\t\t\treturn material;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse FBX material and return parameters suitable for a three.js material\n\t\t\t\t\t\t// Also parse the texture map and return any textures associated with the material\n\t\t\t\t\t\tparseParameters: function (materialNode, textureMap, ID) {\n\n\t\t\t\t\t\t\t\t\tvar parameters = {};\n\n\t\t\t\t\t\t\t\t\tif (materialNode.BumpFactor) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.bumpScale = materialNode.BumpFactor.value;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode.Diffuse) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.color = new THREE.Color().fromArray(materialNode.Diffuse.value);\n\t\t\t\t\t\t\t\t\t} else if (materialNode.DiffuseColor && materialNode.DiffuseColor.type === 'Color') {\n\t\t\t\t\t\t\t\t\t\t\t\t// The blender exporter exports diffuse here instead of in materialNode.Diffuse\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.color = new THREE.Color().fromArray(materialNode.DiffuseColor.value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode.DisplacementFactor) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.displacementScale = materialNode.DisplacementFactor.value;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode.Emissive) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.emissive = new THREE.Color().fromArray(materialNode.Emissive.value);\n\t\t\t\t\t\t\t\t\t} else if (materialNode.EmissiveColor && materialNode.EmissiveColor.type === 'Color') {\n\t\t\t\t\t\t\t\t\t\t\t\t// The blender exporter exports emissive color here instead of in materialNode.Emissive\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.emissive = new THREE.Color().fromArray(materialNode.EmissiveColor.value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode.EmissiveFactor) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode.Opacity) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.opacity = parseFloat(materialNode.Opacity.value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (parameters.opacity < 1.0) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode.ReflectionFactor) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.reflectivity = materialNode.ReflectionFactor.value;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode.Shininess) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.shininess = materialNode.Shininess.value;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode.Specular) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.specular = new THREE.Color().fromArray(materialNode.Specular.value);\n\t\t\t\t\t\t\t\t\t} else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {\n\t\t\t\t\t\t\t\t\t\t\t\t// The blender exporter exports specular color here instead of in materialNode.Specular\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.specular = new THREE.Color().fromArray(materialNode.SpecularColor.value);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// meatbags [1]: Maya PBR keys\n\t\t\t\t\t\t\t\t\tif (materialNode['Maya|base_color']) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.color = new THREE.Color().fromArray(materialNode['Maya|base_color'].value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode['Maya|emissive']) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.emissive = new THREE.Color().fromArray(materialNode['Maya|emissive'].value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode['Maya|emissive_intensity']) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.emissiveIntensity = parseFloat(materialNode['Maya|emissive_intensity'].value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode['Maya|metallic']) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.metalness = parseFloat(materialNode['Maya|metallic'].value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (materialNode['Maya|roughness']) {\n\t\t\t\t\t\t\t\t\t\t\t\tparameters.roughness = parseFloat(materialNode['Maya|roughness'].value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// end changes\n\n\t\t\t\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\t\t\t\tconnections.get(ID).children.forEach(function (child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar type = child.relationship;\n\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Bump':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.bumpMap = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Maya|TEX_ao_map':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.aoMap = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'DiffuseColor':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Maya|TEX_color_map':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.map = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'DisplacementColor':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.displacementMap = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'EmissiveColor':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.emissiveMap = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'NormalMap':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Maya|TEX_normal_map':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.normalMap = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'ReflectionColor':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.envMap = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.envMap.mapping = THREE.EquirectangularReflectionMapping;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'SpecularColor':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.specularMap = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'TransparentColor':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.alphaMap = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.transparent = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// meatbags [2]: Maya PBR map keys\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Maya|TEX_roughness_map':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.roughnessMap = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Maya|TEX_metallic_map':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.metalnessMap = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Maya|emissive_map':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tparameters.emissiveMap = self.getTexture(textureMap, child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Maya|TEX_brdf_lut':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Maya|TEX_global_specular_cube':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Maya|TEX_global_diffuse_cube':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// end changes\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'AmbientColor':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'ShininessExponent': // AKA glossiness map\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'SpecularFactor': // AKA specularLevel\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn parameters;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// get a texture from the textureMap for use by a material.\n\t\t\t\t\t\tgetTexture: function (textureMap, id) {\n\n\t\t\t\t\t\t\t\t\t// if the texture is a layered texture, just use the first layer and issue a warning\n\t\t\t\t\t\t\t\t\tif ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');\n\t\t\t\t\t\t\t\t\t\t\t\tid = connections.get(id).children[0].ID;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn textureMap.get(id);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse nodes in FBXTree.Objects.Deformer\n\t\t\t\t\t\t// Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here\n\t\t\t\t\t\t// Generates map of Skeleton-like objects for use later when generating and binding skeletons.\n\t\t\t\t\t\tparseDeformers: function () {\n\n\t\t\t\t\t\t\t\t\tvar skeletons = {};\n\t\t\t\t\t\t\t\t\tvar morphTargets = {};\n\n\t\t\t\t\t\t\t\t\tif ('Deformer' in fbxTree.Objects) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar DeformerNodes = fbxTree.Objects.Deformer;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var nodeID in DeformerNodes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar deformerNode = DeformerNodes[nodeID];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar relationships = connections.get(parseInt(nodeID));\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (deformerNode.attrType === 'Skin') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar skeleton = this.parseSkeleton(relationships, DeformerNodes);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tskeleton.ID = nodeID;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (relationships.parents.length > 1) console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tskeleton.geometryID = relationships.parents[0].ID;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tskeletons[nodeID] = skeleton;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (deformerNode.attrType === 'BlendShape') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar morphTarget = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: nodeID\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphTarget.id = nodeID;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (relationships.parents.length > 1) console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphTargets[nodeID] = morphTarget;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn {\n\n\t\t\t\t\t\t\t\t\t\t\t\tskeletons: skeletons,\n\t\t\t\t\t\t\t\t\t\t\t\tmorphTargets: morphTargets\n\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse single nodes in FBXTree.Objects.Deformer\n\t\t\t\t\t\t// The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'\n\t\t\t\t\t\t// Each skin node represents a skeleton and each cluster node represents a bone\n\t\t\t\t\t\tparseSkeleton: function (relationships, deformerNodes) {\n\n\t\t\t\t\t\t\t\t\tvar rawBones = [];\n\n\t\t\t\t\t\t\t\t\trelationships.children.forEach(function (child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar boneNode = deformerNodes[child.ID];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (boneNode.attrType !== 'Cluster') return;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar rawBone = {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tID: child.ID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindices: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweights: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttransformLink: new THREE.Matrix4().fromArray(boneNode.TransformLink.a)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// transform: new THREE.Matrix4().fromArray( boneNode.Transform.a ),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// linkMode: boneNode.Mode,\n\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ('Indexes' in boneNode) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trawBone.indices = boneNode.Indexes.a;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trawBone.weights = boneNode.Weights.a;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\trawBones.push(rawBone);\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn {\n\n\t\t\t\t\t\t\t\t\t\t\t\trawBones: rawBones,\n\t\t\t\t\t\t\t\t\t\t\t\tbones: []\n\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// The top level morph deformer node has type \"BlendShape\" and sub nodes have type \"BlendShapeChannel\"\n\t\t\t\t\t\tparseMorphTargets: function (relationships, deformerNodes) {\n\n\t\t\t\t\t\t\t\t\tvar rawMorphTargets = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < relationships.children.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar child = relationships.children[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar morphTargetNode = deformerNodes[child.ID];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar rawMorphTarget = {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: morphTargetNode.attrName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinitialWeight: morphTargetNode.DeformPercent,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: morphTargetNode.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfullWeights: morphTargetNode.FullWeights.a\n\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (morphTargetNode.attrType !== 'BlendShapeChannel') return;\n\n\t\t\t\t\t\t\t\t\t\t\t\trawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn child.relationship === undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t})[0].ID;\n\n\t\t\t\t\t\t\t\t\t\t\t\trawMorphTargets.push(rawMorphTarget);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn rawMorphTargets;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// create the main THREE.Group() to be returned by the loader\n\t\t\t\t\t\tparseScene: function (deformers, geometryMap, materialMap) {\n\n\t\t\t\t\t\t\t\t\tsceneGraph = new THREE.Group();\n\n\t\t\t\t\t\t\t\t\tvar modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);\n\n\t\t\t\t\t\t\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\t\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\t\t\t\tmodelMap.forEach(function (model) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar modelNode = modelNodes[model.ID];\n\t\t\t\t\t\t\t\t\t\t\t\tself.setLookAtProperties(model, modelNode);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar parentConnections = connections.get(model.ID).parents;\n\n\t\t\t\t\t\t\t\t\t\t\t\tparentConnections.forEach(function (connection) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar parent = modelMap.get(connection.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (parent !== undefined) parent.add(model);\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (model.parent === null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsceneGraph.add(model);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tthis.bindSkeleton(deformers.skeletons, geometryMap, modelMap);\n\n\t\t\t\t\t\t\t\t\tthis.createAmbientLight();\n\n\t\t\t\t\t\t\t\t\tthis.setupMorphMaterials();\n\n\t\t\t\t\t\t\t\t\tsceneGraph.traverse(function (node) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (node.userData.transformData) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (node.parent) node.userData.transformData.parentMatrixWorld = node.parent.matrix;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar transform = generateTransform(node.userData.transformData);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode.applyMatrix(transform);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tvar animations = new AnimationParser().parse();\n\n\t\t\t\t\t\t\t\t\t// if all the models where already combined in a single group, just return that\n\t\t\t\t\t\t\t\t\tif (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tsceneGraph.children[0].animations = animations;\n\t\t\t\t\t\t\t\t\t\t\t\tsceneGraph = sceneGraph.children[0];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tsceneGraph.animations = animations;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// parse nodes in FBXTree.Objects.Model\n\t\t\t\t\t\tparseModels: function (skeletons, geometryMap, materialMap) {\n\n\t\t\t\t\t\t\t\t\tvar modelMap = new Map();\n\t\t\t\t\t\t\t\t\tvar modelNodes = fbxTree.Objects.Model;\n\n\t\t\t\t\t\t\t\t\tfor (var nodeID in modelNodes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar id = parseInt(nodeID);\n\t\t\t\t\t\t\t\t\t\t\t\tvar node = modelNodes[nodeID];\n\t\t\t\t\t\t\t\t\t\t\t\tvar relationships = connections.get(id);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar model = this.buildSkeleton(relationships, skeletons, id, node.attrName);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (!model) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (node.attrType) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Camera':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = this.createCamera(relationships);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Light':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = this.createLight(relationships);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = this.createMesh(relationships, geometryMap, materialMap);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = this.createCurve(relationships, geometryMap);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'LimbNode':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Root':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Bone();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'Null':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Group();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.name = THREE.PropertyBinding.sanitizeNodeName(node.attrName);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.ID = id;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.getTransformData(model, node);\n\t\t\t\t\t\t\t\t\t\t\t\tmodelMap.set(id, model);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn modelMap;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tbuildSkeleton: function (relationships, skeletons, id, name) {\n\n\t\t\t\t\t\t\t\t\tvar bone = null;\n\n\t\t\t\t\t\t\t\t\trelationships.parents.forEach(function (parent) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var ID in skeletons) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar skeleton = skeletons[ID];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tskeleton.rawBones.forEach(function (rawBone, i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (rawBone.ID === parent.ID) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar subBone = bone;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbone = new THREE.Bone();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbone.matrixWorld.copy(rawBone.transformLink);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// set name and id here - otherwise in cases where \"subBone\" is created it will not have a name / id\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbone.name = THREE.PropertyBinding.sanitizeNodeName(name);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbone.ID = id;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tskeleton.bones[i] = bone;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// In cases where a bone is shared between multiple meshes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// duplicate the bone here and and it as a child of the first bone\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (subBone !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbone.add(subBone);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn bone;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// create a THREE.PerspectiveCamera or THREE.OrthographicCamera\n\t\t\t\t\t\tcreateCamera: function (relationships) {\n\n\t\t\t\t\t\t\t\t\tvar model;\n\t\t\t\t\t\t\t\t\tvar cameraAttribute;\n\n\t\t\t\t\t\t\t\t\trelationships.children.forEach(function (child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[child.ID];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (attr !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcameraAttribute = attr;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tif (cameraAttribute === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar type = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tif (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype = 1;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar nearClippingPlane = 1;\n\t\t\t\t\t\t\t\t\t\t\t\tif (cameraAttribute.NearPlane !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnearClippingPlane = cameraAttribute.NearPlane.value / 1000;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar farClippingPlane = 1000;\n\t\t\t\t\t\t\t\t\t\t\t\tif (cameraAttribute.FarPlane !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfarClippingPlane = cameraAttribute.FarPlane.value / 1000;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar width = window.innerWidth;\n\t\t\t\t\t\t\t\t\t\t\t\tvar height = window.innerHeight;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twidth = cameraAttribute.AspectWidth.value;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\theight = cameraAttribute.AspectHeight.value;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar aspect = width / height;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar fov = 45;\n\t\t\t\t\t\t\t\t\t\t\t\tif (cameraAttribute.FieldOfView !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfov = cameraAttribute.FieldOfView.value;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;\n\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Perspective\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (focalLength !== null) model.setFocalLength(focalLength);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Orthographic\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn model;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Create a THREE.DirectionalLight, THREE.PointLight or THREE.SpotLight\n\t\t\t\t\t\tcreateLight: function (relationships) {\n\n\t\t\t\t\t\t\t\t\tvar model;\n\t\t\t\t\t\t\t\t\tvar lightAttribute;\n\n\t\t\t\t\t\t\t\t\trelationships.children.forEach(function (child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar attr = fbxTree.Objects.NodeAttribute[child.ID];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (attr !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlightAttribute = attr;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tif (lightAttribute === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Object3D();\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar type;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// LightType can be undefined for Point lights\n\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.LightType === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttype = lightAttribute.LightType.value;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar color = 0xffffff;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.Color !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolor = new THREE.Color().fromArray(lightAttribute.Color.value);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// light disabled\n\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tintensity = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar distance = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.FarAttenuationEnd !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdistance = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdistance = lightAttribute.FarAttenuationEnd.value;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?\n\t\t\t\t\t\t\t\t\t\t\t\tvar decay = 1;\n\n\t\t\t\t\t\t\t\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Point\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.PointLight(color, intensity, distance, decay);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Directional\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.DirectionalLight(color, intensity);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Spot\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar angle = Math.PI / 3;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.InnerAngle !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tangle = THREE.Math.degToRad(lightAttribute.InnerAngle.value);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar penumbra = 0;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.OuterAngle !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// TODO: this is not correct - FBX calculates outer and inner angle in degrees\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// with OuterAngle > InnerAngle && OuterAngle <= Math.PI\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// while three.js uses a penumbra between (0, 1) to attenuate the inner angle\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpenumbra = THREE.Math.degToRad(lightAttribute.OuterAngle.value);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpenumbra = Math.max(penumbra, 1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.SpotLight(color, intensity, distance, angle, penumbra, decay);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a THREE.PointLight.');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.PointLight(color, intensity);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.castShadow = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn model;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcreateMesh: function (relationships, geometryMap, materialMap) {\n\n\t\t\t\t\t\t\t\t\tvar model;\n\t\t\t\t\t\t\t\t\tvar geometry = null;\n\t\t\t\t\t\t\t\t\tvar material = null;\n\t\t\t\t\t\t\t\t\tvar materials = [];\n\n\t\t\t\t\t\t\t\t\t// get geometry and materials(s) from connections\n\t\t\t\t\t\t\t\t\trelationships.children.forEach(function (child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geometryMap.has(child.ID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeometry = geometryMap.get(child.ID);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (materialMap.has(child.ID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterials.push(materialMap.get(child.ID));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tif (materials.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmaterial = materials;\n\t\t\t\t\t\t\t\t\t} else if (materials.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmaterial = materials[0];\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial({ color: 0xcccccc });\n\t\t\t\t\t\t\t\t\t\t\t\tmaterials.push(material);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif ('color' in geometry.attributes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmaterials.forEach(function (material) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial.vertexColors = THREE.VertexColors;\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geometry.FBX_Deformer) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmaterials.forEach(function (material) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial.skinning = true;\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.SkinnedMesh(geometry, material);\n\t\t\t\t\t\t\t\t\t\t\t\tmodel.normalizeSkinWeights();\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmodel = new THREE.Mesh(geometry, material);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn model;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tcreateCurve: function (relationships, geometryMap) {\n\n\t\t\t\t\t\t\t\t\tvar geometry = relationships.children.reduce(function (geo, child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn geo;\n\t\t\t\t\t\t\t\t\t}, null);\n\n\t\t\t\t\t\t\t\t\t// FBX does not list materials for Nurbs lines, so we'll just put our own in here.\n\t\t\t\t\t\t\t\t\tvar material = new THREE.LineBasicMaterial({ color: 0x3300ff, linewidth: 1 });\n\t\t\t\t\t\t\t\t\treturn new THREE.Line(geometry, material);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// parse the model node for transform data\n\t\t\t\t\t\tgetTransformData: function (model, modelNode) {\n\n\t\t\t\t\t\t\t\t\tvar transformData = {};\n\n\t\t\t\t\t\t\t\t\tif ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\n\n\t\t\t\t\t\t\t\t\tif ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);else transformData.eulerOrder = 'ZYX';\n\n\t\t\t\t\t\t\t\t\tif ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t\t\tif ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value;\n\t\t\t\t\t\t\t\t\tif ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;\n\t\t\t\t\t\t\t\t\tif ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value;\n\n\t\t\t\t\t\t\t\t\tif ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;\n\n\t\t\t\t\t\t\t\t\tif ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;\n\t\t\t\t\t\t\t\t\tif ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;\n\n\t\t\t\t\t\t\t\t\tif ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;\n\t\t\t\t\t\t\t\t\tif ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;\n\n\t\t\t\t\t\t\t\t\tmodel.userData.transformData = transformData;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetLookAtProperties: function (model, modelNode) {\n\n\t\t\t\t\t\t\t\t\tif ('LookAtProperty' in modelNode) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar children = connections.get(model.ID).children;\n\n\t\t\t\t\t\t\t\t\t\t\t\tchildren.forEach(function (child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (child.relationship === 'LookAtProperty') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lookAtTarget = fbxTree.Objects.Model[child.ID];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ('Lcl_Translation' in lookAtTarget) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar pos = lookAtTarget.Lcl_Translation.value;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// DirectionalLight, SpotLight\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (model.target !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.target.position.fromArray(pos);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsceneGraph.add(model.target);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Cameras and other Object3Ds\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.lookAt(new THREE.Vector3().fromArray(pos));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tbindSkeleton: function (skeletons, geometryMap, modelMap) {\n\n\t\t\t\t\t\t\t\t\tvar bindMatrices = this.parsePoseNodes();\n\n\t\t\t\t\t\t\t\t\tfor (var ID in skeletons) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar skeleton = skeletons[ID];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar parents = connections.get(parseInt(skeleton.ID)).parents;\n\n\t\t\t\t\t\t\t\t\t\t\t\tparents.forEach(function (parent) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometryMap.has(parent.ID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar geoID = parent.ID;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar geoRelationships = connections.get(geoID);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeoRelationships.parents.forEach(function (geoConnParent) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (modelMap.has(geoConnParent.ID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar model = modelMap.get(geoConnParent.ID);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodel.bind(new THREE.Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tparsePoseNodes: function () {\n\n\t\t\t\t\t\t\t\t\tvar bindMatrices = {};\n\n\t\t\t\t\t\t\t\t\tif ('Pose' in fbxTree.Objects) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar BindPoseNode = fbxTree.Objects.Pose;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var nodeID in BindPoseNode) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (BindPoseNode[nodeID].attrType === 'BindPose') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar poseNodes = BindPoseNode[nodeID].PoseNode;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(poseNodes)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tposeNodes.forEach(function (poseNode) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbindMatrices[poseNode.Node] = new THREE.Matrix4().fromArray(poseNode.Matrix.a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbindMatrices[poseNodes.Node] = new THREE.Matrix4().fromArray(poseNodes.Matrix.a);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn bindMatrices;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light\n\t\t\t\t\t\tcreateAmbientLight: function () {\n\n\t\t\t\t\t\t\t\t\tif ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar ambientColor = fbxTree.GlobalSettings.AmbientColor.value;\n\t\t\t\t\t\t\t\t\t\t\t\tvar r = ambientColor[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar g = ambientColor[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar b = ambientColor[2];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (r !== 0 || g !== 0 || b !== 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar color = new THREE.Color(r, g, b);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsceneGraph.add(new THREE.AmbientLight(color, 1));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetupMorphMaterials: function () {\n\n\t\t\t\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\t\t\t\tsceneGraph.traverse(function (child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (child.isMesh) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (child.geometry.morphAttributes.position && child.geometry.morphAttributes.position.length) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(child.material)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchild.material.forEach(function (material, i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself.setupMorphMaterial(child, material, i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself.setupMorphMaterial(child, child.material);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetupMorphMaterial: function (child, material, index) {\n\n\t\t\t\t\t\t\t\t\tvar uuid = child.uuid;\n\t\t\t\t\t\t\t\t\tvar matUuid = material.uuid;\n\n\t\t\t\t\t\t\t\t\t// if a geometry has morph targets, it cannot share the material with other geometries\n\t\t\t\t\t\t\t\t\tvar sharedMat = false;\n\n\t\t\t\t\t\t\t\t\tsceneGraph.traverse(function (node) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (node.isMesh) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(node.material)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode.material.forEach(function (mat) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (mat.uuid === matUuid && node.uuid !== uuid) sharedMat = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (node.material.uuid === matUuid && node.uuid !== uuid) sharedMat = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tif (sharedMat === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar clonedMat = material.clone();\n\t\t\t\t\t\t\t\t\t\t\t\tclonedMat.morphTargets = true;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (index === undefined) child.material = clonedMat;else child.material[index] = clonedMat;\n\t\t\t\t\t\t\t\t\t} else material.morphTargets = true;\n\t\t\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t// parse Geometry data from FBXTree and return map of BufferGeometries\n\t\t\tfunction GeometryParser() {}\n\n\t\t\tGeometryParser.prototype = {\n\n\t\t\t\t\t\tconstructor: GeometryParser,\n\n\t\t\t\t\t\t// Parse nodes in FBXTree.Objects.Geometry\n\t\t\t\t\t\tparse: function (deformers) {\n\n\t\t\t\t\t\t\t\t\tvar geometryMap = new Map();\n\n\t\t\t\t\t\t\t\t\tif ('Geometry' in fbxTree.Objects) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar geoNodes = fbxTree.Objects.Geometry;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var nodeID in geoNodes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar relationships = connections.get(parseInt(nodeID));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeometryMap.set(parseInt(nodeID), geo);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn geometryMap;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse single node in FBXTree.Objects.Geometry\n\t\t\t\t\t\tparseGeometry: function (relationships, geoNode, deformers) {\n\n\t\t\t\t\t\t\t\t\tswitch (geoNode.attrType) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'Mesh':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.parseMeshGeometry(relationships, geoNode, deformers);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'NurbsCurve':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.parseNurbsGeometry(geoNode);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse single node mesh geometry in FBXTree.Objects.Geometry\n\t\t\t\t\t\tparseMeshGeometry: function (relationships, geoNode, deformers) {\n\n\t\t\t\t\t\t\t\t\tvar skeletons = deformers.skeletons;\n\t\t\t\t\t\t\t\t\tvar morphTargets = deformers.morphTargets;\n\n\t\t\t\t\t\t\t\t\tvar modelNodes = relationships.parents.map(function (parent) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn fbxTree.Objects.Model[parent.ID];\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t// don't create geometry if it is not associated with any models\n\t\t\t\t\t\t\t\t\tif (modelNodes.length === 0) return;\n\n\t\t\t\t\t\t\t\t\tvar skeleton = relationships.children.reduce(function (skeleton, child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn skeleton;\n\t\t\t\t\t\t\t\t\t}, null);\n\n\t\t\t\t\t\t\t\t\tvar morphTarget = relationships.children.reduce(function (morphTarget, child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (morphTargets[child.ID] !== undefined) morphTarget = morphTargets[child.ID];\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn morphTarget;\n\t\t\t\t\t\t\t\t\t}, null);\n\n\t\t\t\t\t\t\t\t\t// Assume one model and get the preRotation from that\n\t\t\t\t\t\t\t\t\t// if there is more than one model associated with the geometry this may cause problems\n\t\t\t\t\t\t\t\t\tvar modelNode = modelNodes[0];\n\n\t\t\t\t\t\t\t\t\tvar transformData = {};\n\n\t\t\t\t\t\t\t\t\tif ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);\n\t\t\t\t\t\t\t\t\tif ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);\n\n\t\t\t\t\t\t\t\t\tif ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value;\n\t\t\t\t\t\t\t\t\tif ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value;\n\t\t\t\t\t\t\t\t\tif ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value;\n\n\t\t\t\t\t\t\t\t\tvar transform = generateTransform(transformData);\n\n\t\t\t\t\t\t\t\t\treturn this.genGeometry(geoNode, skeleton, morphTarget, transform);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Generate a THREE.BufferGeometry from a node in FBXTree.Objects.Geometry\n\t\t\t\t\t\tgenGeometry: function (geoNode, skeleton, morphTarget, preTransform) {\n\n\t\t\t\t\t\t\t\t\tvar geo = new THREE.BufferGeometry();\n\t\t\t\t\t\t\t\t\tif (geoNode.attrName) geo.name = geoNode.attrName;\n\n\t\t\t\t\t\t\t\t\tvar geoInfo = this.parseGeoNode(geoNode, skeleton);\n\t\t\t\t\t\t\t\t\tvar buffers = this.genBuffers(geoInfo);\n\n\t\t\t\t\t\t\t\t\tvar positionAttribute = new THREE.Float32BufferAttribute(buffers.vertex, 3);\n\n\t\t\t\t\t\t\t\t\tpreTransform.applyToBufferAttribute(positionAttribute);\n\n\t\t\t\t\t\t\t\t\tgeo.addAttribute('position', positionAttribute);\n\n\t\t\t\t\t\t\t\t\tif (buffers.colors.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeo.addAttribute('color', new THREE.Float32BufferAttribute(buffers.colors, 3));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (skeleton) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeo.addAttribute('skinIndex', new THREE.Uint16BufferAttribute(buffers.weightsIndices, 4));\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeo.addAttribute('skinWeight', new THREE.Float32BufferAttribute(buffers.vertexWeights, 4));\n\n\t\t\t\t\t\t\t\t\t\t\t\t// used later to bind the skeleton to the model\n\t\t\t\t\t\t\t\t\t\t\t\tgeo.FBX_Deformer = skeleton;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (buffers.normal.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar normalAttribute = new THREE.Float32BufferAttribute(buffers.normal, 3);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix(preTransform);\n\t\t\t\t\t\t\t\t\t\t\t\tnormalMatrix.applyToBufferAttribute(normalAttribute);\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeo.addAttribute('normal', normalAttribute);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbuffers.uvs.forEach(function (uvBuffer, i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// subsequent uv buffers are called 'uv1', 'uv2', ...\n\t\t\t\t\t\t\t\t\t\t\t\tvar name = 'uv' + (i + 1).toString();\n\n\t\t\t\t\t\t\t\t\t\t\t\t// the first uv buffer is just called 'uv'\n\t\t\t\t\t\t\t\t\t\t\t\tif (i === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname = 'uv';\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeo.addAttribute(name, new THREE.Float32BufferAttribute(buffers.uvs[i], 2));\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tif (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Convert the material indices of each vertex into rendering groups on the geometry.\n\t\t\t\t\t\t\t\t\t\t\t\tvar prevMaterialIndex = buffers.materialIndex[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar startIndex = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\tbuffers.materialIndex.forEach(function (currentIndex, i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (currentIndex !== prevMaterialIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeo.addGroup(startIndex, i - startIndex, prevMaterialIndex);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprevMaterialIndex = currentIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstartIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\t// the loop above doesn't add the last group, do that here.\n\t\t\t\t\t\t\t\t\t\t\t\tif (geo.groups.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lastGroup = geo.groups[geo.groups.length - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lastIndex = lastGroup.start + lastGroup.count;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lastIndex !== buffers.materialIndex.length) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// case where there are multiple materials but the whole geometry is only\n\t\t\t\t\t\t\t\t\t\t\t\t// using one of them\n\t\t\t\t\t\t\t\t\t\t\t\tif (geo.groups.length === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.addMorphTargets(geo, geoNode, morphTarget, preTransform);\n\n\t\t\t\t\t\t\t\t\treturn geo;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tparseGeoNode: function (geoNode, skeleton) {\n\n\t\t\t\t\t\t\t\t\tvar geoInfo = {};\n\n\t\t\t\t\t\t\t\t\tgeoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];\n\t\t\t\t\t\t\t\t\tgeoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];\n\n\t\t\t\t\t\t\t\t\tif (geoNode.LayerElementColor) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geoNode.LayerElementMaterial) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geoNode.LayerElementNormal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (geoNode.LayerElementUV) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeoInfo.uv = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar i = 0;\n\t\t\t\t\t\t\t\t\t\t\t\twhile (geoNode.LayerElementUV[i]) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tgeoInfo.weightTable = {};\n\n\t\t\t\t\t\t\t\t\tif (skeleton !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tgeoInfo.skeleton = skeleton;\n\n\t\t\t\t\t\t\t\t\t\t\t\tskeleton.rawBones.forEach(function (rawBone, i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// loop over the bone's vertex indices and weights\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\trawBone.indices.forEach(function (index, j) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeoInfo.weightTable[index].push({\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: i,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweight: rawBone.weights[j]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn geoInfo;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgenBuffers: function (geoInfo) {\n\n\t\t\t\t\t\t\t\t\tvar buffers = {\n\t\t\t\t\t\t\t\t\t\t\t\tvertex: [],\n\t\t\t\t\t\t\t\t\t\t\t\tnormal: [],\n\t\t\t\t\t\t\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\t\t\t\t\t\t\tuvs: [],\n\t\t\t\t\t\t\t\t\t\t\t\tmaterialIndex: [],\n\t\t\t\t\t\t\t\t\t\t\t\tvertexWeights: [],\n\t\t\t\t\t\t\t\t\t\t\t\tweightsIndices: []\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tvar polygonIndex = 0;\n\t\t\t\t\t\t\t\t\tvar faceLength = 0;\n\t\t\t\t\t\t\t\t\tvar displayedWeightsWarning = false;\n\n\t\t\t\t\t\t\t\t\t// these will hold data for a single face\n\t\t\t\t\t\t\t\t\tvar facePositionIndexes = [];\n\t\t\t\t\t\t\t\t\tvar faceNormals = [];\n\t\t\t\t\t\t\t\t\tvar faceColors = [];\n\t\t\t\t\t\t\t\t\tvar faceUVs = [];\n\t\t\t\t\t\t\t\t\tvar faceWeights = [];\n\t\t\t\t\t\t\t\t\tvar faceWeightIndices = [];\n\n\t\t\t\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\t\t\t\tgeoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar endOfFace = false;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Face index and vertex index arrays are combined in a single array\n\t\t\t\t\t\t\t\t\t\t\t\t// A cube with quad faces looks like this:\n\t\t\t\t\t\t\t\t\t\t\t\t// PolygonVertexIndex: *24 {\n\t\t\t\t\t\t\t\t\t\t\t\t//  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5\n\t\t\t\t\t\t\t\t\t\t\t\t//  }\n\t\t\t\t\t\t\t\t\t\t\t\t// Negative numbers mark the end of a face - first face here is 0, 1, 3, -3\n\t\t\t\t\t\t\t\t\t\t\t\t// to find index of last vertex bit shift the index: ^ - 1\n\t\t\t\t\t\t\t\t\t\t\t\tif (vertexIndex < 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tendOfFace = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar weightIndices = [];\n\t\t\t\t\t\t\t\t\t\t\t\tvar weights = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tfacePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.color) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceColors.push(data[0], data[1], data[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.skeleton) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.weightTable[vertexIndex] !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeoInfo.weightTable[vertexIndex].forEach(function (wt) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweights.push(wt.weight);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweightIndices.push(wt.id);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (weights.length > 4) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!displayedWeightsWarning) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdisplayedWeightsWarning = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar wIndex = [0, 0, 0, 0];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar Weight = [0, 0, 0, 0];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweights.forEach(function (weight, weightIndex) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar currentWeight = weight;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar currentIndex = weightIndices[weightIndex];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tWeight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (currentWeight > comparedWeight) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcomparedWeightArray[comparedWeightIndex] = currentWeight;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentWeight = comparedWeight;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar tmp = wIndex[comparedWeightIndex];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twIndex[comparedWeightIndex] = currentIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentIndex = tmp;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweightIndices = wIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweights = Weight;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if the weight array is shorter than 4 pad with 0s\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (weights.length < 4) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweights.push(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tweightIndices.push(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < 4; ++i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceWeights.push(weights[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceWeightIndices.push(weightIndices[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.normal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceNormals.push(data[0], data[1], data[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.uv) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeoInfo.uv.forEach(function (uv, i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (faceUVs[i] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceUVs[i] = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceUVs[i].push(data[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceUVs[i].push(data[1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tfaceLength++;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (endOfFace) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpolygonIndex++;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceLength = 0;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// reset arrays for the next face\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfacePositionIndexes = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceNormals = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceColors = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceUVs = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceWeights = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceWeightIndices = [];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn buffers;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris\n\t\t\t\t\t\tgenFace: function (buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {\n\n\t\t\t\t\t\t\t\t\tfor (var i = 2; i < faceLength; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);\n\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);\n\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);\n\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);\n\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);\n\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);\n\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.skeleton) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[3]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4 + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.vertexWeights.push(faceWeights[i * 4 + 3]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[3]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.color) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.colors.push(faceColors[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.colors.push(faceColors[1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.colors.push(faceColors[2]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.colors.push(faceColors[(i - 1) * 3]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.colors.push(faceColors[(i - 1) * 3 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.colors.push(faceColors[(i - 1) * 3 + 2]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.colors.push(faceColors[i * 3]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.colors.push(faceColors[i * 3 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.colors.push(faceColors[i * 3 + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.materialIndex.push(materialIndex);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.materialIndex.push(materialIndex);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.materialIndex.push(materialIndex);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.normal) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.normal.push(faceNormals[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.normal.push(faceNormals[1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.normal.push(faceNormals[2]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.normal.push(faceNormals[(i - 1) * 3]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.normal.push(faceNormals[(i - 1) * 3 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.normal.push(faceNormals[(i - 1) * 3 + 2]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.normal.push(faceNormals[i * 3]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.normal.push(faceNormals[i * 3 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.normal.push(faceNormals[i * 3 + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (geoInfo.uv) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeoInfo.uv.forEach(function (uv, j) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (buffers.uvs[j] === undefined) buffers.uvs[j] = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][1]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][i * 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffers.uvs[j].push(faceUVs[j][i * 2 + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddMorphTargets: function (parentGeo, parentGeoNode, morphTarget, preTransform) {\n\n\t\t\t\t\t\t\t\t\tif (morphTarget === null) return;\n\n\t\t\t\t\t\t\t\t\tparentGeo.morphAttributes.position = [];\n\t\t\t\t\t\t\t\t\t// parentGeo.morphAttributes.normal = []; // not implemented\n\n\t\t\t\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\t\t\t\tmorphTarget.rawTargets.forEach(function (rawTarget) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (morphGeoNode !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// a morph geometry node is similar to a standard  node, and the node is also contained\n\t\t\t\t\t\t// in FBXTree.Objects.Geometry, however it can only have attributes for position, normal\n\t\t\t\t\t\t// and a special attribute Index defining which vertices of the original geometry are affected\n\t\t\t\t\t\t// Normal and position attributes only have data for the vertices that are affected by the morph\n\t\t\t\t\t\tgenMorphGeometry: function (parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {\n\n\t\t\t\t\t\t\t\t\tvar morphGeo = new THREE.BufferGeometry();\n\t\t\t\t\t\t\t\t\tif (morphGeoNode.attrName) morphGeo.name = morphGeoNode.attrName;\n\n\t\t\t\t\t\t\t\t\tvar vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];\n\n\t\t\t\t\t\t\t\t\t// make a copy of the parent's vertex positions\n\t\t\t\t\t\t\t\t\tvar vertexPositions = parentGeoNode.Vertices !== undefined ? parentGeoNode.Vertices.a.slice() : [];\n\n\t\t\t\t\t\t\t\t\tvar morphPositions = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];\n\t\t\t\t\t\t\t\t\tvar indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < indices.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar morphIndex = indices[i] * 3;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// FBX format uses blend shapes rather than morph targets. This can be converted\n\t\t\t\t\t\t\t\t\t\t\t\t// by additively combining the blend shape positions with the original geometry's positions\n\t\t\t\t\t\t\t\t\t\t\t\tvertexPositions[morphIndex] += morphPositions[i * 3];\n\t\t\t\t\t\t\t\t\t\t\t\tvertexPositions[morphIndex + 1] += morphPositions[i * 3 + 1];\n\t\t\t\t\t\t\t\t\t\t\t\tvertexPositions[morphIndex + 2] += morphPositions[i * 3 + 2];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// TODO: add morph normal support\n\t\t\t\t\t\t\t\t\tvar morphGeoInfo = {\n\t\t\t\t\t\t\t\t\t\t\t\tvertexIndices: vertexIndices,\n\t\t\t\t\t\t\t\t\t\t\t\tvertexPositions: vertexPositions\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tvar morphBuffers = this.genBuffers(morphGeoInfo);\n\n\t\t\t\t\t\t\t\t\tvar positionAttribute = new THREE.Float32BufferAttribute(morphBuffers.vertex, 3);\n\t\t\t\t\t\t\t\t\tpositionAttribute.name = name || morphGeoNode.attrName;\n\n\t\t\t\t\t\t\t\t\tpreTransform.applyToBufferAttribute(positionAttribute);\n\n\t\t\t\t\t\t\t\t\tparentGeo.morphAttributes.position.push(positionAttribute);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists\n\t\t\t\t\t\tparseNormals: function (NormalNode) {\n\n\t\t\t\t\t\t\t\t\tvar mappingType = NormalNode.MappingInformationType;\n\t\t\t\t\t\t\t\t\tvar referenceType = NormalNode.ReferenceInformationType;\n\t\t\t\t\t\t\t\t\tvar buffer = NormalNode.Normals.a;\n\t\t\t\t\t\t\t\t\tvar indexBuffer = [];\n\t\t\t\t\t\t\t\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif ('NormalIndex' in NormalNode) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindexBuffer = NormalNode.NormalIndex.a;\n\t\t\t\t\t\t\t\t\t\t\t\t} else if ('NormalsIndex' in NormalNode) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindexBuffer = NormalNode.NormalsIndex.a;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\t\tdataSize: 3,\n\t\t\t\t\t\t\t\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\t\t\t\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\t\t\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists\n\t\t\t\t\t\tparseUVs: function (UVNode) {\n\n\t\t\t\t\t\t\t\t\tvar mappingType = UVNode.MappingInformationType;\n\t\t\t\t\t\t\t\t\tvar referenceType = UVNode.ReferenceInformationType;\n\t\t\t\t\t\t\t\t\tvar buffer = UVNode.UV.a;\n\t\t\t\t\t\t\t\t\tvar indexBuffer = [];\n\t\t\t\t\t\t\t\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindexBuffer = UVNode.UVIndex.a;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\t\tdataSize: 2,\n\t\t\t\t\t\t\t\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\t\t\t\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\t\t\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists\n\t\t\t\t\t\tparseVertexColors: function (ColorNode) {\n\n\t\t\t\t\t\t\t\t\tvar mappingType = ColorNode.MappingInformationType;\n\t\t\t\t\t\t\t\t\tvar referenceType = ColorNode.ReferenceInformationType;\n\t\t\t\t\t\t\t\t\tvar buffer = ColorNode.Colors.a;\n\t\t\t\t\t\t\t\t\tvar indexBuffer = [];\n\t\t\t\t\t\t\t\t\tif (referenceType === 'IndexToDirect') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tindexBuffer = ColorNode.ColorIndex.a;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\t\tdataSize: 4,\n\t\t\t\t\t\t\t\t\t\t\t\tbuffer: buffer,\n\t\t\t\t\t\t\t\t\t\t\t\tindices: indexBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\t\t\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists\n\t\t\t\t\t\tparseMaterialIndices: function (MaterialNode) {\n\n\t\t\t\t\t\t\t\t\tvar mappingType = MaterialNode.MappingInformationType;\n\t\t\t\t\t\t\t\t\tvar referenceType = MaterialNode.ReferenceInformationType;\n\n\t\t\t\t\t\t\t\t\tif (mappingType === 'NoMappingInformation') {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdataSize: 1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffer: [0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindices: [0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmappingType: 'AllSame',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar materialIndexBuffer = MaterialNode.Materials.a;\n\n\t\t\t\t\t\t\t\t\t// Since materials are stored as indices, there's a bit of a mismatch between FBX and what\n\t\t\t\t\t\t\t\t\t// we expect.So we create an intermediate buffer that points to the index in the buffer,\n\t\t\t\t\t\t\t\t\t// for conforming with the other functions we've written for other data.\n\t\t\t\t\t\t\t\t\tvar materialIndices = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < materialIndexBuffer.length; ++i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tmaterialIndices.push(i);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\t\tdataSize: 1,\n\t\t\t\t\t\t\t\t\t\t\t\tbuffer: materialIndexBuffer,\n\t\t\t\t\t\t\t\t\t\t\t\tindices: materialIndices,\n\t\t\t\t\t\t\t\t\t\t\t\tmappingType: mappingType,\n\t\t\t\t\t\t\t\t\t\t\t\treferenceType: referenceType\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Generate a NurbGeometry from a node in FBXTree.Objects.Geometry\n\t\t\t\t\t\tparseNurbsGeometry: function (geoNode) {\n\n\t\t\t\t\t\t\t\t\tif (THREE.NURBSCurve === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.FBXLoader: The loader relies on THREE.NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');\n\t\t\t\t\t\t\t\t\t\t\t\treturn new THREE.BufferGeometry();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar order = parseInt(geoNode.Order);\n\n\t\t\t\t\t\t\t\t\tif (isNaN(order)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);\n\t\t\t\t\t\t\t\t\t\t\t\treturn new THREE.BufferGeometry();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar degree = order - 1;\n\n\t\t\t\t\t\t\t\t\tvar knots = geoNode.KnotVector.a;\n\t\t\t\t\t\t\t\t\tvar controlPoints = [];\n\t\t\t\t\t\t\t\t\tvar pointsValues = geoNode.Points.a;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, l = pointsValues.length; i < l; i += 4) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcontrolPoints.push(new THREE.Vector4().fromArray(pointsValues, i));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar startKnot, endKnot;\n\n\t\t\t\t\t\t\t\t\tif (geoNode.Form === 'Closed') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcontrolPoints.push(controlPoints[0]);\n\t\t\t\t\t\t\t\t\t} else if (geoNode.Form === 'Periodic') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tstartKnot = degree;\n\t\t\t\t\t\t\t\t\t\t\t\tendKnot = knots.length - 1 - startKnot;\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0; i < degree; ++i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontrolPoints.push(controlPoints[i]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar curve = new THREE.NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);\n\t\t\t\t\t\t\t\t\tvar vertices = curve.getPoints(controlPoints.length * 7);\n\n\t\t\t\t\t\t\t\t\tvar positions = new Float32Array(vertices.length * 3);\n\n\t\t\t\t\t\t\t\t\tvertices.forEach(function (vertex, i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertex.toArray(positions, i * 3);\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tvar geometry = new THREE.BufferGeometry();\n\t\t\t\t\t\t\t\t\tgeometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));\n\n\t\t\t\t\t\t\t\t\treturn geometry;\n\t\t\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t// parse animation data from FBXTree\n\t\t\tfunction AnimationParser() {}\n\n\t\t\tAnimationParser.prototype = {\n\n\t\t\t\t\t\tconstructor: AnimationParser,\n\n\t\t\t\t\t\t// take raw animation clips and turn them into three.js animation clips\n\t\t\t\t\t\tparse: function () {\n\n\t\t\t\t\t\t\t\t\tvar animationClips = [];\n\n\t\t\t\t\t\t\t\t\tvar rawClips = this.parseClips();\n\n\t\t\t\t\t\t\t\t\tif (rawClips !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var key in rawClips) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar rawClip = rawClips[key];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar clip = this.addClip(rawClip);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tanimationClips.push(clip);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn animationClips;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tparseClips: function () {\n\n\t\t\t\t\t\t\t\t\t// since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,\n\t\t\t\t\t\t\t\t\t// if this is undefined we can safely assume there are no animations\n\t\t\t\t\t\t\t\t\tif (fbxTree.Objects.AnimationCurve === undefined) return undefined;\n\n\t\t\t\t\t\t\t\t\tvar curveNodesMap = this.parseAnimationCurveNodes();\n\n\t\t\t\t\t\t\t\t\tthis.parseAnimationCurves(curveNodesMap);\n\n\t\t\t\t\t\t\t\t\tvar layersMap = this.parseAnimationLayers(curveNodesMap);\n\t\t\t\t\t\t\t\t\tvar rawClips = this.parseAnimStacks(layersMap);\n\n\t\t\t\t\t\t\t\t\treturn rawClips;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// parse nodes in FBXTree.Objects.AnimationCurveNode\n\t\t\t\t\t\t// each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )\n\t\t\t\t\t\t// and is referenced by an AnimationLayer\n\t\t\t\t\t\tparseAnimationCurveNodes: function () {\n\n\t\t\t\t\t\t\t\t\tvar rawCurveNodes = fbxTree.Objects.AnimationCurveNode;\n\n\t\t\t\t\t\t\t\t\tvar curveNodesMap = new Map();\n\n\t\t\t\t\t\t\t\t\tfor (var nodeID in rawCurveNodes) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar rawCurveNode = rawCurveNodes[nodeID];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar curveNode = {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: rawCurveNode.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattr: rawCurveNode.attrName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurves: {}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurveNodesMap.set(curveNode.id, curveNode);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn curveNodesMap;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// parse nodes in FBXTree.Objects.AnimationCurve and connect them up to\n\t\t\t\t\t\t// previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated\n\t\t\t\t\t\t// axis ( e.g. times and values of x rotation)\n\t\t\t\t\t\tparseAnimationCurves: function (curveNodesMap) {\n\n\t\t\t\t\t\t\t\t\tvar rawCurves = fbxTree.Objects.AnimationCurve;\n\n\t\t\t\t\t\t\t\t\t// TODO: Many values are identical up to roundoff error, but won't be optimised\n\t\t\t\t\t\t\t\t\t// e.g. position times: [0, 0.4, 0. 8]\n\t\t\t\t\t\t\t\t\t// position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]\n\t\t\t\t\t\t\t\t\t// clearly, this should be optimised to\n\t\t\t\t\t\t\t\t\t// times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]\n\t\t\t\t\t\t\t\t\t// this shows up in nearly every FBX file, and generally time array is length > 100\n\n\t\t\t\t\t\t\t\t\tfor (var nodeID in rawCurves) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar animationCurve = {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: rawCurves[nodeID].id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttimes: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues: rawCurves[nodeID].KeyValueFloat.a\n\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar relationships = connections.get(animationCurve.id);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (relationships !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar animationCurveID = relationships.parents[0].ID;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar animationCurveRelationship = relationships.parents[0].relationship;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (animationCurveRelationship.match(/X/)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurveNodesMap.get(animationCurveID).curves['x'] = animationCurve;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (animationCurveRelationship.match(/Y/)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurveNodesMap.get(animationCurveID).curves['y'] = animationCurve;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (animationCurveRelationship.match(/Z/)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurveNodesMap.get(animationCurveID).curves['z'] = animationCurve;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurveNodesMap.get(animationCurveID).curves['morph'] = animationCurve;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references\n\t\t\t\t\t\t// to various AnimationCurveNodes and is referenced by an AnimationStack node\n\t\t\t\t\t\t// note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack\n\t\t\t\t\t\tparseAnimationLayers: function (curveNodesMap) {\n\n\t\t\t\t\t\t\t\t\tvar rawLayers = fbxTree.Objects.AnimationLayer;\n\n\t\t\t\t\t\t\t\t\tvar layersMap = new Map();\n\n\t\t\t\t\t\t\t\t\tfor (var nodeID in rawLayers) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar layerCurveNodes = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar connection = connections.get(parseInt(nodeID));\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (connection !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// all the animationCurveNodes used in the layer\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar children = connection.children;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchildren.forEach(function (child, i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (curveNodesMap.has(child.ID)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar curveNode = curveNodesMap.get(child.ID);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check that the curves are defined for at least one axis, otherwise ignore the curveNode\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (layerCurveNodes[i] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar modelID = connections.get(child.ID).parents.filter(function (parent) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t})[0].ID;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (modelID !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[modelID.toString()];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodelName: THREE.PropertyBinding.sanitizeNodeName(rawModel.attrName),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tID: rawModel.id,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinitialPosition: [0, 0, 0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinitialRotation: [0, 0, 0],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinitialScale: [1, 1, 1]\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsceneGraph.traverse(function (child) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (child.ID === rawModel.id) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode.transform = child.matrix;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!node.transform) node.transform = new THREE.Matrix4();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if the animated model is pre rotated, we'll have to apply the pre rotations to every\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// animation value as well\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlayerCurveNodes[i] = node;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (curveNode.curves.morph !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (layerCurveNodes[i] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar deformerID = connections.get(child.ID).parents.filter(function (parent) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn parent.relationship !== undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t})[0].ID;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar morpherID = connections.get(deformerID).parents[0].ID;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar geoID = connections.get(morpherID).parents[0].ID;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// assuming geometry is not used in more than one model\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar modelID = connections.get(geoID).parents[0].ID;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar rawModel = fbxTree.Objects.Model[modelID];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar node = {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodelName: THREE.PropertyBinding.sanitizeNodeName(rawModel.attrName),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmorphName: fbxTree.Objects.Deformer[deformerID].attrName\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlayerCurveNodes[i] = node;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlayerCurveNodes[i][curveNode.attr] = curveNode;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlayersMap.set(parseInt(nodeID), layerCurveNodes);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn layersMap;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation\n\t\t\t\t\t\t// hierarchy. Each Stack node will be used to create a THREE.AnimationClip\n\t\t\t\t\t\tparseAnimStacks: function (layersMap) {\n\n\t\t\t\t\t\t\t\t\tvar rawStacks = fbxTree.Objects.AnimationStack;\n\n\t\t\t\t\t\t\t\t\t// connect the stacks (clips) up to the layers\n\t\t\t\t\t\t\t\t\tvar rawClips = {};\n\n\t\t\t\t\t\t\t\t\tfor (var nodeID in rawStacks) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar children = connections.get(parseInt(nodeID)).children;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (children.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// it seems like stacks will always be associated with a single layer. But just in case there are files\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// where there are multiple layers per stack, we'll display a warning\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar layer = layersMap.get(children[0].ID);\n\n\t\t\t\t\t\t\t\t\t\t\t\trawClips[nodeID] = {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: rawStacks[nodeID].attrName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlayer: layer\n\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn rawClips;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\taddClip: function (rawClip) {\n\n\t\t\t\t\t\t\t\t\tvar tracks = [];\n\n\t\t\t\t\t\t\t\t\tvar self = this;\n\t\t\t\t\t\t\t\t\trawClip.layer.forEach(function (rawTracks) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ttracks = tracks.concat(self.generateTracks(rawTracks));\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn new THREE.AnimationClip(rawClip.name, -1, tracks);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgenerateTracks: function (rawTracks) {\n\n\t\t\t\t\t\t\t\t\tvar tracks = [];\n\n\t\t\t\t\t\t\t\t\tvar initialPosition = new THREE.Vector3();\n\t\t\t\t\t\t\t\t\tvar initialRotation = new THREE.Quaternion();\n\t\t\t\t\t\t\t\t\tvar initialScale = new THREE.Vector3();\n\n\t\t\t\t\t\t\t\t\tif (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);\n\n\t\t\t\t\t\t\t\t\tinitialPosition = initialPosition.toArray();\n\t\t\t\t\t\t\t\t\tinitialRotation = new THREE.Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();\n\t\t\t\t\t\t\t\t\tinitialScale = initialScale.toArray();\n\n\t\t\t\t\t\t\t\t\tif (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position');\n\t\t\t\t\t\t\t\t\t\t\t\tif (positionTrack !== undefined) tracks.push(positionTrack);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);\n\t\t\t\t\t\t\t\t\t\t\t\tif (rotationTrack !== undefined) tracks.push(rotationTrack);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale');\n\t\t\t\t\t\t\t\t\t\t\t\tif (scaleTrack !== undefined) tracks.push(scaleTrack);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (rawTracks.DeformPercent !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar morphTrack = this.generateMorphTrack(rawTracks);\n\t\t\t\t\t\t\t\t\t\t\t\tif (morphTrack !== undefined) tracks.push(morphTrack);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn tracks;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgenerateVectorTrack: function (modelName, curves, initialValue, type) {\n\n\t\t\t\t\t\t\t\t\tvar times = this.getTimesForAllAxes(curves);\n\t\t\t\t\t\t\t\t\tvar values = this.getKeyframeTrackValues(times, curves, initialValue);\n\n\t\t\t\t\t\t\t\t\treturn new THREE.VectorKeyframeTrack(modelName + '.' + type, times, values);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgenerateRotationTrack: function (modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {\n\n\t\t\t\t\t\t\t\t\tif (curves.x !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.interpolateRotations(curves.x);\n\t\t\t\t\t\t\t\t\t\t\t\tcurves.x.values = curves.x.values.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (curves.y !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.interpolateRotations(curves.y);\n\t\t\t\t\t\t\t\t\t\t\t\tcurves.y.values = curves.y.values.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (curves.z !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.interpolateRotations(curves.z);\n\t\t\t\t\t\t\t\t\t\t\t\tcurves.z.values = curves.z.values.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar times = this.getTimesForAllAxes(curves);\n\t\t\t\t\t\t\t\t\tvar values = this.getKeyframeTrackValues(times, curves, initialValue);\n\n\t\t\t\t\t\t\t\t\tif (preRotation !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpreRotation = preRotation.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\t\t\t\t\tpreRotation.push(eulerOrder);\n\n\t\t\t\t\t\t\t\t\t\t\t\tpreRotation = new THREE.Euler().fromArray(preRotation);\n\t\t\t\t\t\t\t\t\t\t\t\tpreRotation = new THREE.Quaternion().setFromEuler(preRotation);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (postRotation !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpostRotation = postRotation.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\t\t\t\t\tpostRotation.push(eulerOrder);\n\n\t\t\t\t\t\t\t\t\t\t\t\tpostRotation = new THREE.Euler().fromArray(postRotation);\n\t\t\t\t\t\t\t\t\t\t\t\tpostRotation = new THREE.Quaternion().setFromEuler(postRotation).inverse();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar quaternion = new THREE.Quaternion();\n\t\t\t\t\t\t\t\t\tvar euler = new THREE.Euler();\n\n\t\t\t\t\t\t\t\t\tvar quaternionValues = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < values.length; i += 3) {\n\n\t\t\t\t\t\t\t\t\t\t\t\teuler.set(values[i], values[i + 1], values[i + 2], eulerOrder);\n\n\t\t\t\t\t\t\t\t\t\t\t\tquaternion.setFromEuler(euler);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (preRotation !== undefined) quaternion.premultiply(preRotation);\n\t\t\t\t\t\t\t\t\t\t\t\tif (postRotation !== undefined) quaternion.multiply(postRotation);\n\n\t\t\t\t\t\t\t\t\t\t\t\tquaternion.toArray(quaternionValues, i / 3 * 4);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn new THREE.QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgenerateMorphTrack: function (rawTracks) {\n\n\t\t\t\t\t\t\t\t\tvar curves = rawTracks.DeformPercent.curves.morph;\n\t\t\t\t\t\t\t\t\tvar values = curves.values.map(function (val) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn val / 100;\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tvar morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];\n\n\t\t\t\t\t\t\t\t\treturn new THREE.NumberKeyframeTrack(rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// For all animated objects, times are defined separately for each axis\n\t\t\t\t\t\t// Here we'll combine the times into one sorted array without duplicates\n\t\t\t\t\t\tgetTimesForAllAxes: function (curves) {\n\n\t\t\t\t\t\t\t\t\tvar times = [];\n\n\t\t\t\t\t\t\t\t\t// first join together the times for each axis, if defined\n\t\t\t\t\t\t\t\t\tif (curves.x !== undefined) times = times.concat(curves.x.times);\n\t\t\t\t\t\t\t\t\tif (curves.y !== undefined) times = times.concat(curves.y.times);\n\t\t\t\t\t\t\t\t\tif (curves.z !== undefined) times = times.concat(curves.z.times);\n\n\t\t\t\t\t\t\t\t\t// then sort them and remove duplicates\n\t\t\t\t\t\t\t\t\ttimes = times.sort(function (a, b) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn a - b;\n\t\t\t\t\t\t\t\t\t}).filter(function (elem, index, array) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn array.indexOf(elem) == index;\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn times;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetKeyframeTrackValues: function (times, curves, initialValue) {\n\n\t\t\t\t\t\t\t\t\tvar prevValue = initialValue;\n\n\t\t\t\t\t\t\t\t\tvar values = [];\n\n\t\t\t\t\t\t\t\t\tvar xIndex = -1;\n\t\t\t\t\t\t\t\t\tvar yIndex = -1;\n\t\t\t\t\t\t\t\t\tvar zIndex = -1;\n\n\t\t\t\t\t\t\t\t\ttimes.forEach(function (time) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (curves.x) xIndex = curves.x.times.indexOf(time);\n\t\t\t\t\t\t\t\t\t\t\t\tif (curves.y) yIndex = curves.y.times.indexOf(time);\n\t\t\t\t\t\t\t\t\t\t\t\tif (curves.z) zIndex = curves.z.times.indexOf(time);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// if there is an x value defined for this frame, use that\n\t\t\t\t\t\t\t\t\t\t\t\tif (xIndex !== -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar xValue = curves.x.values[xIndex];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues.push(xValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprevValue[0] = xValue;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// otherwise use the x value from the previous frame\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues.push(prevValue[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (yIndex !== -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar yValue = curves.y.values[yIndex];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues.push(yValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprevValue[1] = yValue;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues.push(prevValue[1]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (zIndex !== -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar zValue = curves.z.values[zIndex];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues.push(zValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprevValue[2] = zValue;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalues.push(prevValue[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn values;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Rotations are defined as Euler angles which can have values  of any size\n\t\t\t\t\t\t// These will be converted to quaternions which don't support values greater than\n\t\t\t\t\t\t// PI, so we'll interpolate large rotations\n\t\t\t\t\t\tinterpolateRotations: function (curve) {\n\n\t\t\t\t\t\t\t\t\tfor (var i = 1; i < curve.values.length; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar initialValue = curve.values[i - 1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar valuesSpan = curve.values[i] - initialValue;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar absoluteSpan = Math.abs(valuesSpan);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (absoluteSpan >= 180) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar numSubIntervals = absoluteSpan / 180;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar step = valuesSpan / numSubIntervals;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar nextValue = initialValue + step;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar initialTime = curve.times[i - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar timeSpan = curve.times[i] - initialTime;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar interval = timeSpan / numSubIntervals;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar nextTime = initialTime + interval;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar interpolatedTimes = [];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar interpolatedValues = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\twhile (nextTime < curve.times[i]) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinterpolatedTimes.push(nextTime);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnextTime += interval;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinterpolatedValues.push(nextValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnextValue += step;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurve.times = inject(curve.times, i, interpolatedTimes);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurve.values = inject(curve.values, i, interpolatedValues);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t// parse an FBX file in ASCII format\n\t\t\tfunction TextParser() {}\n\n\t\t\tTextParser.prototype = {\n\n\t\t\t\t\t\tconstructor: TextParser,\n\n\t\t\t\t\t\tgetPrevNode: function () {\n\n\t\t\t\t\t\t\t\t\treturn this.nodeStack[this.currentIndent - 2];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetCurrentNode: function () {\n\n\t\t\t\t\t\t\t\t\treturn this.nodeStack[this.currentIndent - 1];\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetCurrentProp: function () {\n\n\t\t\t\t\t\t\t\t\treturn this.currentProp;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tpushStack: function (node) {\n\n\t\t\t\t\t\t\t\t\tthis.nodeStack.push(node);\n\t\t\t\t\t\t\t\t\tthis.currentIndent += 1;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tpopStack: function () {\n\n\t\t\t\t\t\t\t\t\tthis.nodeStack.pop();\n\t\t\t\t\t\t\t\t\tthis.currentIndent -= 1;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsetCurrentProp: function (val, name) {\n\n\t\t\t\t\t\t\t\t\tthis.currentProp = val;\n\t\t\t\t\t\t\t\t\tthis.currentPropName = name;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tparse: function (text) {\n\n\t\t\t\t\t\t\t\t\tthis.currentIndent = 0;\n\n\t\t\t\t\t\t\t\t\tthis.allNodes = new FBXTree();\n\t\t\t\t\t\t\t\t\tthis.nodeStack = [];\n\t\t\t\t\t\t\t\t\tthis.currentProp = [];\n\t\t\t\t\t\t\t\t\tthis.currentPropName = '';\n\n\t\t\t\t\t\t\t\t\tvar self = this;\n\n\t\t\t\t\t\t\t\t\tvar split = text.split(/[\\r\\n]+/);\n\n\t\t\t\t\t\t\t\t\tsplit.forEach(function (line, i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar matchComment = line.match(/^[\\s\\t]*;/);\n\t\t\t\t\t\t\t\t\t\t\t\tvar matchEmpty = line.match(/^[\\s\\t]*$/);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (matchComment || matchEmpty) return;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar matchBeginning = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):(.*){', '');\n\t\t\t\t\t\t\t\t\t\t\t\tvar matchProperty = line.match('^\\\\t{' + self.currentIndent + '}(\\\\w+):[\\\\s\\\\t\\\\r\\\\n](.*)');\n\t\t\t\t\t\t\t\t\t\t\t\tvar matchEnd = line.match('^\\\\t{' + (self.currentIndent - 1) + '}}');\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (matchBeginning) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself.parseNodeBegin(line, matchBeginning);\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (matchProperty) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself.parseNodeProperty(line, matchProperty, split[++i]);\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (matchEnd) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself.popStack();\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (line.match(/^[^\\s\\t}]/)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// large arrays are split over multiple lines terminated with a ',' character\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// if this is encountered the line needs to be joined to the previous line\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tself.parseNodePropertyContinued(line);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn this.allNodes;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tparseNodeBegin: function (line, property) {\n\n\t\t\t\t\t\t\t\t\tvar nodeName = property[1].trim().replace(/^\"/, '').replace(/\"$/, '');\n\n\t\t\t\t\t\t\t\t\tvar nodeAttrs = property[2].split(',').map(function (attr) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn attr.trim().replace(/^\"/, '').replace(/\"$/, '');\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tvar node = { name: nodeName };\n\t\t\t\t\t\t\t\t\tvar attrs = this.parseNodeAttr(nodeAttrs);\n\n\t\t\t\t\t\t\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t\t\t\t\t\t\t// a top node\n\t\t\t\t\t\t\t\t\tif (this.currentIndent === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.allNodes.add(nodeName, node);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t// a subnode\n\n\t\t\t\t\t\t\t\t\t\t\t\t// if the subnode already exists, append it\n\t\t\t\t\t\t\t\t\t\t\t\tif (nodeName in currentNode) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// special case Pose needs PoseNodes as an array\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (nodeName === 'PoseNode') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode.PoseNode.push(node);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (currentNode[nodeName].id !== undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode[nodeName] = {};\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (attrs.id !== '') currentNode[nodeName][attrs.id] = node;\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (typeof attrs.id === 'number') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode[nodeName] = {};\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode[nodeName][attrs.id] = node;\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (nodeName !== 'Properties70') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (typeof attrs.id === 'number') node.id = attrs.id;\n\t\t\t\t\t\t\t\t\tif (attrs.name !== '') node.attrName = attrs.name;\n\t\t\t\t\t\t\t\t\tif (attrs.type !== '') node.attrType = attrs.type;\n\n\t\t\t\t\t\t\t\t\tthis.pushStack(node);\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tparseNodeAttr: function (attrs) {\n\n\t\t\t\t\t\t\t\t\tvar id = attrs[0];\n\n\t\t\t\t\t\t\t\t\tif (attrs[0] !== '') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tid = parseInt(attrs[0]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (isNaN(id)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid = attrs[0];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar name = '',\n\t\t\t\t\t\t\t\t\t    type = '';\n\n\t\t\t\t\t\t\t\t\tif (attrs.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tname = attrs[1].replace(/^(\\w+)::/, '');\n\t\t\t\t\t\t\t\t\t\t\t\ttype = attrs[2];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn { id: id, name: name, type: type };\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tparseNodeProperty: function (line, property, contentLine) {\n\n\t\t\t\t\t\t\t\t\tvar propName = property[1].replace(/^\"/, '').replace(/\"$/, '').trim();\n\t\t\t\t\t\t\t\t\tvar propValue = property[2].replace(/^\"/, '').replace(/\"$/, '').trim();\n\n\t\t\t\t\t\t\t\t\t// for special case: base64 image data follows \"Content: ,\" line\n\t\t\t\t\t\t\t\t\t//\tContent: ,\n\t\t\t\t\t\t\t\t\t//\t \"/9j/4RDaRXhpZgAATU0A...\"\n\t\t\t\t\t\t\t\t\tif (propName === 'Content' && propValue === ',') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpropValue = contentLine.replace(/\"/g, '').replace(/,$/, '').trim();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar currentNode = this.getCurrentNode();\n\t\t\t\t\t\t\t\t\tvar parentName = currentNode.name;\n\n\t\t\t\t\t\t\t\t\tif (parentName === 'Properties70') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.parseNodeSpecialProperty(line, propName, propValue);\n\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Connections\n\t\t\t\t\t\t\t\t\tif (propName === 'C') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar connProps = propValue.split(',').slice(1);\n\t\t\t\t\t\t\t\t\t\t\t\tvar from = parseInt(connProps[0]);\n\t\t\t\t\t\t\t\t\t\t\t\tvar to = parseInt(connProps[1]);\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar rest = propValue.split(',').slice(3);\n\n\t\t\t\t\t\t\t\t\t\t\t\trest = rest.map(function (elem) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn elem.trim().replace(/^\"/, '');\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\tpropName = 'connections';\n\t\t\t\t\t\t\t\t\t\t\t\tpropValue = [from, to];\n\t\t\t\t\t\t\t\t\t\t\t\tappend(propValue, rest);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (currentNode[propName] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode[propName] = [];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Node\n\t\t\t\t\t\t\t\t\tif (propName === 'Node') currentNode.id = propValue;\n\n\t\t\t\t\t\t\t\t\t// connections\n\t\t\t\t\t\t\t\t\tif (propName in currentNode && Array.isArray(currentNode[propName])) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode[propName].push(propValue);\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tthis.setCurrentProp(currentNode, propName);\n\n\t\t\t\t\t\t\t\t\t// convert string to array, unless it ends in ',' in which case more will be added to it\n\t\t\t\t\t\t\t\t\tif (propName === 'a' && propValue.slice(-1) !== ',') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode.a = parseNumberArray(propValue);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tparseNodePropertyContinued: function (line) {\n\n\t\t\t\t\t\t\t\t\tvar currentNode = this.getCurrentNode();\n\n\t\t\t\t\t\t\t\t\tcurrentNode.a += line;\n\n\t\t\t\t\t\t\t\t\t// if the line doesn't end in ',' we have reached the end of the property value\n\t\t\t\t\t\t\t\t\t// so convert the string to an array\n\t\t\t\t\t\t\t\t\tif (line.slice(-1) !== ',') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcurrentNode.a = parseNumberArray(currentNode.a);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// parse \"Property70\"\n\t\t\t\t\t\tparseNodeSpecialProperty: function (line, propName, propValue) {\n\n\t\t\t\t\t\t\t\t\t// split this\n\t\t\t\t\t\t\t\t\t// P: \"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\",1,1,1\n\t\t\t\t\t\t\t\t\t// into array like below\n\t\t\t\t\t\t\t\t\t// [\"Lcl Scaling\", \"Lcl Scaling\", \"\", \"A\", \"1,1,1\" ]\n\t\t\t\t\t\t\t\t\tvar props = propValue.split('\",').map(function (prop) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn prop.trim().replace(/^\\\"/, '').replace(/\\s/, '_');\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\tvar innerPropName = props[0];\n\t\t\t\t\t\t\t\t\tvar innerPropType1 = props[1];\n\t\t\t\t\t\t\t\t\tvar innerPropType2 = props[2];\n\t\t\t\t\t\t\t\t\tvar innerPropFlag = props[3];\n\t\t\t\t\t\t\t\t\tvar innerPropValue = props[4];\n\n\t\t\t\t\t\t\t\t\t// cast values where needed, otherwise leave as strings\n\t\t\t\t\t\t\t\t\tswitch (innerPropType1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'int':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'enum':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'bool':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'ULongLong':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'double':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'Number':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'FieldOfView':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinnerPropValue = parseFloat(innerPropValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'Color':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'ColorRGB':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'Vector3D':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'Lcl_Translation':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'Lcl_Rotation':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'Lcl_Scaling':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinnerPropValue = parseNumberArray(innerPropValue);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// CAUTION: these props must append to parent's parent\n\t\t\t\t\t\t\t\t\tthis.getPrevNode()[innerPropName] = {\n\n\t\t\t\t\t\t\t\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t\t\t\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t\t\t\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t\t\t\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tthis.setCurrentProp(this.getPrevNode(), innerPropName);\n\t\t\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t// Parse an FBX file in Binary format\n\t\t\tfunction BinaryParser() {}\n\n\t\t\tBinaryParser.prototype = {\n\n\t\t\t\t\t\tconstructor: BinaryParser,\n\n\t\t\t\t\t\tparse: function (buffer) {\n\n\t\t\t\t\t\t\t\t\tvar reader = new BinaryReader(buffer);\n\t\t\t\t\t\t\t\t\treader.skip(23); // skip magic 23 bytes\n\n\t\t\t\t\t\t\t\t\tvar version = reader.getUint32();\n\n\t\t\t\t\t\t\t\t\tconsole.log('THREE.FBXLoader: FBX binary version: ' + version);\n\n\t\t\t\t\t\t\t\t\tvar allNodes = new FBXTree();\n\n\t\t\t\t\t\t\t\t\twhile (!this.endOfContent(reader)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar node = this.parseNode(reader, version);\n\t\t\t\t\t\t\t\t\t\t\t\tif (node !== null) allNodes.add(node.name, node);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn allNodes;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Check if reader has reached the end of content.\n\t\t\t\t\t\tendOfContent: function (reader) {\n\n\t\t\t\t\t\t\t\t\t// footer size: 160bytes + 16-byte alignment padding\n\t\t\t\t\t\t\t\t\t// - 16bytes: magic\n\t\t\t\t\t\t\t\t\t// - padding til 16-byte alignment (at least 1byte?)\n\t\t\t\t\t\t\t\t\t//\t(seems like some exporters embed fixed 15 or 16bytes?)\n\t\t\t\t\t\t\t\t\t// - 4bytes: magic\n\t\t\t\t\t\t\t\t\t// - 4bytes: version\n\t\t\t\t\t\t\t\t\t// - 120bytes: zero\n\t\t\t\t\t\t\t\t\t// - 16bytes: magic\n\t\t\t\t\t\t\t\t\tif (reader.size() % 16 === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getOffset() + 160 + 16 >= reader.size();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// recursively parse nodes until the end of the file is reached\n\t\t\t\t\t\tparseNode: function (reader, version) {\n\n\t\t\t\t\t\t\t\t\tvar node = {};\n\n\t\t\t\t\t\t\t\t\t// The first three data sizes depends on version.\n\t\t\t\t\t\t\t\t\tvar endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\t\t\t\t\t\t\t\t\tvar numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\n\t\t\t\t\t\t\t\t\t// note: do not remove this even if you get a linter warning as it moves the buffer forward\n\t\t\t\t\t\t\t\t\tvar propertyListLen = version >= 7500 ? reader.getUint64() : reader.getUint32();\n\n\t\t\t\t\t\t\t\t\tvar nameLen = reader.getUint8();\n\t\t\t\t\t\t\t\t\tvar name = reader.getString(nameLen);\n\n\t\t\t\t\t\t\t\t\t// Regards this node as NULL-record if endOffset is zero\n\t\t\t\t\t\t\t\t\tif (endOffset === 0) return null;\n\n\t\t\t\t\t\t\t\t\tvar propertyList = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < numProperties; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tpropertyList.push(this.parseProperty(reader));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Regards the first three elements in propertyList as id, attrName, and attrType\n\t\t\t\t\t\t\t\t\tvar id = propertyList.length > 0 ? propertyList[0] : '';\n\t\t\t\t\t\t\t\t\tvar attrName = propertyList.length > 1 ? propertyList[1] : '';\n\t\t\t\t\t\t\t\t\tvar attrType = propertyList.length > 2 ? propertyList[2] : '';\n\n\t\t\t\t\t\t\t\t\t// check if this node represents just a single property\n\t\t\t\t\t\t\t\t\t// like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}\n\t\t\t\t\t\t\t\t\tnode.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;\n\n\t\t\t\t\t\t\t\t\twhile (endOffset > reader.getOffset()) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar subNode = this.parseNode(reader, version);\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (subNode !== null) this.parseSubNode(name, node, subNode);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tnode.propertyList = propertyList; // raw property list used by parent\n\n\t\t\t\t\t\t\t\t\tif (typeof id === 'number') node.id = id;\n\t\t\t\t\t\t\t\t\tif (attrName !== '') node.attrName = attrName;\n\t\t\t\t\t\t\t\t\tif (attrType !== '') node.attrType = attrType;\n\t\t\t\t\t\t\t\t\tif (name !== '') node.name = name;\n\n\t\t\t\t\t\t\t\t\treturn node;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tparseSubNode: function (name, node, subNode) {\n\n\t\t\t\t\t\t\t\t\t// special case: child node is single property\n\t\t\t\t\t\t\t\t\tif (subNode.singleProperty === true) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar value = subNode.propertyList[0];\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode[subNode.name] = subNode;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsubNode.a = value;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode[subNode.name] = value;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (name === 'Connections' && subNode.name === 'C') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar array = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\tsubNode.propertyList.forEach(function (property, i) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// first Connection is FBX type (OO, OP, etc.). We'll discard these\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (i !== 0) array.push(property);\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (node.connections === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode.connections = [];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tnode.connections.push(array);\n\t\t\t\t\t\t\t\t\t} else if (subNode.name === 'Properties70') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar keys = Object.keys(subNode);\n\n\t\t\t\t\t\t\t\t\t\t\t\tkeys.forEach(function (key) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode[key] = subNode[key];\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t} else if (name === 'Properties70' && subNode.name === 'P') {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar innerPropName = subNode.propertyList[0];\n\t\t\t\t\t\t\t\t\t\t\t\tvar innerPropType1 = subNode.propertyList[1];\n\t\t\t\t\t\t\t\t\t\t\t\tvar innerPropType2 = subNode.propertyList[2];\n\t\t\t\t\t\t\t\t\t\t\t\tvar innerPropFlag = subNode.propertyList[3];\n\t\t\t\t\t\t\t\t\t\t\t\tvar innerPropValue;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');\n\t\t\t\t\t\t\t\t\t\t\t\tif (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinnerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinnerPropValue = subNode.propertyList[4];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// this will be copied to parent, see above\n\t\t\t\t\t\t\t\t\t\t\t\tnode[innerPropName] = {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'type': innerPropType1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'type2': innerPropType2,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'flag': innerPropFlag,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'value': innerPropValue\n\n\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t} else if (node[subNode.name] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (typeof subNode.id === 'number') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode[subNode.name] = {};\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode[subNode.name][subNode.id] = subNode;\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode[subNode.name] = subNode;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (subNode.name === 'PoseNode') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!Array.isArray(node[subNode.name])) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode[subNode.name] = [node[subNode.name]];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode[subNode.name].push(subNode);\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (node[subNode.name][subNode.id] === undefined) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode[subNode.name][subNode.id] = subNode;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tparseProperty: function (reader) {\n\n\t\t\t\t\t\t\t\t\tvar type = reader.getString(1);\n\n\t\t\t\t\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'C':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getBoolean();\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'D':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getFloat64();\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'F':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getFloat32();\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'I':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getInt32();\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'L':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getInt64();\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'R':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getArrayBuffer(length);\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'S':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar length = reader.getUint32();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getString(length);\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'Y':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getInt16();\n\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\t\t\t\t\tcase 'l':\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar arrayLength = reader.getUint32();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar encoding = reader.getUint32(); // 0: non-compressed, 1: compressed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar compressedLength = reader.getUint32();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (encoding === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getBooleanArray(arrayLength);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getFloat64Array(arrayLength);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getFloat32Array(arrayLength);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getInt32Array(arrayLength);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader.getInt64Array(arrayLength);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (typeof Zlib === 'undefined') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconsole.error('THREE.FBXLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar inflate = new Zlib.Inflate(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar reader2 = new BinaryReader(inflate.decompress().buffer);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (type) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'b':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader2.getBooleanArray(arrayLength);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'd':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader2.getFloat64Array(arrayLength);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'f':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader2.getFloat32Array(arrayLength);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'i':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader2.getInt32Array(arrayLength);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn reader2.getInt64Array(arrayLength);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('THREE.FBXLoader: Unknown property type ' + type);\n\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t};\n\n\t\t\tfunction BinaryReader(buffer, littleEndian) {\n\n\t\t\t\t\t\tthis.dv = new DataView(buffer);\n\t\t\t\t\t\tthis.offset = 0;\n\t\t\t\t\t\tthis.littleEndian = littleEndian !== undefined ? littleEndian : true;\n\t\t\t}\n\n\t\t\tBinaryReader.prototype = {\n\n\t\t\t\t\t\tconstructor: BinaryReader,\n\n\t\t\t\t\t\tgetOffset: function () {\n\n\t\t\t\t\t\t\t\t\treturn this.offset;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tsize: function () {\n\n\t\t\t\t\t\t\t\t\treturn this.dv.buffer.byteLength;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tskip: function (length) {\n\n\t\t\t\t\t\t\t\t\tthis.offset += length;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// seems like true/false representation depends on exporter.\n\t\t\t\t\t\t// true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)\n\t\t\t\t\t\t// then sees LSB.\n\t\t\t\t\t\tgetBoolean: function () {\n\n\t\t\t\t\t\t\t\t\treturn (this.getUint8() & 1) === 1;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetBooleanArray: function (size) {\n\n\t\t\t\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ta.push(this.getBoolean());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetUint8: function () {\n\n\t\t\t\t\t\t\t\t\tvar value = this.dv.getUint8(this.offset);\n\t\t\t\t\t\t\t\t\tthis.offset += 1;\n\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetInt16: function () {\n\n\t\t\t\t\t\t\t\t\tvar value = this.dv.getInt16(this.offset, this.littleEndian);\n\t\t\t\t\t\t\t\t\tthis.offset += 2;\n\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetInt32: function () {\n\n\t\t\t\t\t\t\t\t\tvar value = this.dv.getInt32(this.offset, this.littleEndian);\n\t\t\t\t\t\t\t\t\tthis.offset += 4;\n\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetInt32Array: function (size) {\n\n\t\t\t\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ta.push(this.getInt32());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetUint32: function () {\n\n\t\t\t\t\t\t\t\t\tvar value = this.dv.getUint32(this.offset, this.littleEndian);\n\t\t\t\t\t\t\t\t\tthis.offset += 4;\n\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// JavaScript doesn't support 64-bit integer so calculate this here\n\t\t\t\t\t\t// 1 << 32 will return 1 so using multiply operation instead here.\n\t\t\t\t\t\t// There's a possibility that this method returns wrong value if the value\n\t\t\t\t\t\t// is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.\n\t\t\t\t\t\t// TODO: safely handle 64-bit integer\n\t\t\t\t\t\tgetInt64: function () {\n\n\t\t\t\t\t\t\t\t\tvar low, high;\n\n\t\t\t\t\t\t\t\t\tif (this.littleEndian) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\t\t\t\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\t\t\t\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// calculate negative value\n\t\t\t\t\t\t\t\t\tif (high & 0x80000000) {\n\n\t\t\t\t\t\t\t\t\t\t\t\thigh = ~high & 0xFFFFFFFF;\n\t\t\t\t\t\t\t\t\t\t\t\tlow = ~low & 0xFFFFFFFF;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;\n\n\t\t\t\t\t\t\t\t\t\t\t\tlow = low + 1 & 0xFFFFFFFF;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn -(high * 0x100000000 + low);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn high * 0x100000000 + low;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetInt64Array: function (size) {\n\n\t\t\t\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ta.push(this.getInt64());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\t// Note: see getInt64() comment\n\t\t\t\t\t\tgetUint64: function () {\n\n\t\t\t\t\t\t\t\t\tvar low, high;\n\n\t\t\t\t\t\t\t\t\tif (this.littleEndian) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\t\t\t\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\thigh = this.getUint32();\n\t\t\t\t\t\t\t\t\t\t\t\tlow = this.getUint32();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn high * 0x100000000 + low;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetFloat32: function () {\n\n\t\t\t\t\t\t\t\t\tvar value = this.dv.getFloat32(this.offset, this.littleEndian);\n\t\t\t\t\t\t\t\t\tthis.offset += 4;\n\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetFloat32Array: function (size) {\n\n\t\t\t\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ta.push(this.getFloat32());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetFloat64: function () {\n\n\t\t\t\t\t\t\t\t\tvar value = this.dv.getFloat64(this.offset, this.littleEndian);\n\t\t\t\t\t\t\t\t\tthis.offset += 8;\n\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetFloat64Array: function (size) {\n\n\t\t\t\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ta.push(this.getFloat64());\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn a;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetArrayBuffer: function (size) {\n\n\t\t\t\t\t\t\t\t\tvar value = this.dv.buffer.slice(this.offset, this.offset + size);\n\t\t\t\t\t\t\t\t\tthis.offset += size;\n\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t},\n\n\t\t\t\t\t\tgetString: function (size) {\n\n\t\t\t\t\t\t\t\t\t// note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead\n\t\t\t\t\t\t\t\t\tvar a = [];\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0; i < size; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\ta[i] = this.getUint8();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar nullByte = a.indexOf(0);\n\t\t\t\t\t\t\t\t\tif (nullByte >= 0) a = a.slice(0, nullByte);\n\n\t\t\t\t\t\t\t\t\treturn THREE.LoaderUtils.decodeText(new Uint8Array(a));\n\t\t\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t// FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)\n\t\t\t// and BinaryParser( FBX Binary format)\n\t\t\tfunction FBXTree() {}\n\n\t\t\tFBXTree.prototype = {\n\n\t\t\t\t\t\tconstructor: FBXTree,\n\n\t\t\t\t\t\tadd: function (key, val) {\n\n\t\t\t\t\t\t\t\t\tthis[key] = val;\n\t\t\t\t\t\t}\n\n\t\t\t};\n\n\t\t\t// ************** UTILITY FUNCTIONS **************\n\n\t\t\tfunction isFbxFormatBinary(buffer) {\n\n\t\t\t\t\t\tvar CORRECT = 'Kaydara FBX Binary  \\0';\n\n\t\t\t\t\t\treturn buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);\n\t\t\t}\n\n\t\t\tfunction isFbxFormatASCII(text) {\n\n\t\t\t\t\t\tvar CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\\\', 'F', 'B', 'X', '\\\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\\\', '\\\\'];\n\n\t\t\t\t\t\tvar cursor = 0;\n\n\t\t\t\t\t\tfunction read(offset) {\n\n\t\t\t\t\t\t\t\t\tvar result = text[offset - 1];\n\t\t\t\t\t\t\t\t\ttext = text.slice(cursor + offset);\n\t\t\t\t\t\t\t\t\tcursor++;\n\t\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (var i = 0; i < CORRECT.length; ++i) {\n\n\t\t\t\t\t\t\t\t\tvar num = read(1);\n\t\t\t\t\t\t\t\t\tif (num === CORRECT[i]) {\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tfunction getFbxVersion(text) {\n\n\t\t\t\t\t\tvar versionRegExp = /FBXVersion: (\\d+)/;\n\t\t\t\t\t\tvar match = text.match(versionRegExp);\n\t\t\t\t\t\tif (match) {\n\n\t\t\t\t\t\t\t\t\tvar version = parseInt(match[1]);\n\t\t\t\t\t\t\t\t\treturn version;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow new Error('THREE.FBXLoader: Cannot find the version number for the file given.');\n\t\t\t}\n\n\t\t\t// Converts FBX ticks into real time seconds.\n\t\t\tfunction convertFBXTimeToSeconds(time) {\n\n\t\t\t\t\t\treturn time / 46186158000;\n\t\t\t}\n\n\t\t\tvar dataArray = [];\n\n\t\t\t// extracts the data from the correct position in the FBX array based on indexing type\n\t\t\tfunction getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {\n\n\t\t\t\t\t\tvar index;\n\n\t\t\t\t\t\tswitch (infoObject.mappingType) {\n\n\t\t\t\t\t\t\t\t\tcase 'ByPolygonVertex':\n\t\t\t\t\t\t\t\t\t\t\t\tindex = polygonVertexIndex;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 'ByPolygon':\n\t\t\t\t\t\t\t\t\t\t\t\tindex = polygonIndex;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 'ByVertice':\n\t\t\t\t\t\t\t\t\t\t\t\tindex = vertexIndex;\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tcase 'AllSame':\n\t\t\t\t\t\t\t\t\t\t\t\tindex = infoObject.indices[0];\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];\n\n\t\t\t\t\t\tvar from = index * infoObject.dataSize;\n\t\t\t\t\t\tvar to = from + infoObject.dataSize;\n\n\t\t\t\t\t\treturn slice(dataArray, infoObject.buffer, from, to);\n\t\t\t}\n\n\t\t\tvar tempEuler = new THREE.Euler();\n\t\t\tvar tempVec = new THREE.Vector3();\n\n\t\t\t// generate transformation from FBX transform data\n\t\t\t// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm\n\t\t\t// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e\n\t\t\tfunction generateTransform(transformData) {\n\n\t\t\t\t\t\tvar lTranslationM = new THREE.Matrix4();\n\t\t\t\t\t\tvar lPreRotationM = new THREE.Matrix4();\n\t\t\t\t\t\tvar lRotationM = new THREE.Matrix4();\n\t\t\t\t\t\tvar lPostRotationM = new THREE.Matrix4();\n\n\t\t\t\t\t\tvar lScalingM = new THREE.Matrix4();\n\t\t\t\t\t\tvar lScalingPivotM = new THREE.Matrix4();\n\t\t\t\t\t\tvar lScalingOffsetM = new THREE.Matrix4();\n\t\t\t\t\t\tvar lRotationOffsetM = new THREE.Matrix4();\n\t\t\t\t\t\tvar lRotationPivotM = new THREE.Matrix4();\n\n\t\t\t\t\t\tvar lParentGX = new THREE.Matrix4();\n\t\t\t\t\t\tvar lGlobalT = new THREE.Matrix4();\n\n\t\t\t\t\t\tvar inheritType = transformData.inheritType ? transformData.inheritType : 0;\n\n\t\t\t\t\t\tif (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));\n\n\t\t\t\t\t\tif (transformData.preRotation) {\n\n\t\t\t\t\t\t\t\t\tvar array = transformData.preRotation.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\t\tarray.push(transformData.eulerOrder);\n\t\t\t\t\t\t\t\t\tlPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (transformData.rotation) {\n\n\t\t\t\t\t\t\t\t\tvar array = transformData.rotation.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\t\tarray.push(transformData.eulerOrder);\n\t\t\t\t\t\t\t\t\tlRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (transformData.postRotation) {\n\n\t\t\t\t\t\t\t\t\tvar array = transformData.postRotation.map(THREE.Math.degToRad);\n\t\t\t\t\t\t\t\t\tarray.push(transformData.eulerOrder);\n\t\t\t\t\t\t\t\t\tlPostRotationM.makeRotationFromEuler(tempEuler.fromArray(array));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale));\n\n\t\t\t\t\t\t// Pivots and offsets\n\t\t\t\t\t\tif (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));\n\t\t\t\t\t\tif (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));\n\t\t\t\t\t\tif (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));\n\t\t\t\t\t\tif (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot));\n\n\t\t\t\t\t\t// parent transform\n\t\t\t\t\t\tif (transformData.parentMatrixWorld) lParentGX = transformData.parentMatrixWorld;\n\n\t\t\t\t\t\t// Global Rotation\n\t\t\t\t\t\tvar lLRM = lPreRotationM.multiply(lRotationM).multiply(lPostRotationM);\n\t\t\t\t\t\tvar lParentGRM = new THREE.Matrix4();\n\t\t\t\t\t\tlParentGX.extractRotation(lParentGRM);\n\n\t\t\t\t\t\t// Global Shear*Scaling\n\t\t\t\t\t\tvar lParentTM = new THREE.Matrix4();\n\t\t\t\t\t\tvar lLSM;\n\t\t\t\t\t\tvar lParentGSM;\n\t\t\t\t\t\tvar lParentGRSM;\n\n\t\t\t\t\t\tlParentTM.copyPosition(lParentGX);\n\t\t\t\t\t\tlParentGRSM = lParentTM.getInverse(lParentTM).multiply(lParentGX);\n\t\t\t\t\t\tlParentGSM = lParentGRM.getInverse(lParentGRM).multiply(lParentGRSM);\n\t\t\t\t\t\tlLSM = lScalingM;\n\n\t\t\t\t\t\tvar lGlobalRS;\n\t\t\t\t\t\tif (inheritType === 0) {\n\n\t\t\t\t\t\t\t\t\tlGlobalRS = lParentGRM.multiply(lLRM).multiply(lParentGSM).multiply(lLSM);\n\t\t\t\t\t\t} else if (inheritType === 1) {\n\n\t\t\t\t\t\t\t\t\tlGlobalRS = lParentGRM.multiply(lParentGSM).multiply(lLRM).multiply(lLSM);\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\tvar lParentLSM = new THREE.Matrix4().copy(lScalingM);\n\n\t\t\t\t\t\t\t\t\tvar lParentGSM_noLocal = lParentGSM.multiply(lParentLSM.getInverse(lParentLSM));\n\n\t\t\t\t\t\t\t\t\tlGlobalRS = lParentGRM.multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Calculate the local transform matrix\n\t\t\t\t\t\tvar lTransform = lTranslationM.multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM.getInverse(lRotationPivotM)).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM.getInverse(lScalingPivotM));\n\n\t\t\t\t\t\tvar lLocalTWithAllPivotAndOffsetInfo = new THREE.Matrix4().copyPosition(lTransform);\n\n\t\t\t\t\t\tvar lGlobalTranslation = lParentGX.multiply(lLocalTWithAllPivotAndOffsetInfo);\n\t\t\t\t\t\tlGlobalT.copyPosition(lGlobalTranslation);\n\n\t\t\t\t\t\tlTransform = lGlobalT.multiply(lGlobalRS);\n\n\t\t\t\t\t\treturn lTransform;\n\t\t\t}\n\n\t\t\t// Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order\n\t\t\t// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html\n\t\t\tfunction getEulerOrder(order) {\n\n\t\t\t\t\t\torder = order || 0;\n\n\t\t\t\t\t\tvar enums = ['ZYX', // -> XYZ extrinsic\n\t\t\t\t\t\t'YZX', // -> XZY extrinsic\n\t\t\t\t\t\t'XZY', // -> YZX extrinsic\n\t\t\t\t\t\t'ZXY', // -> YXZ extrinsic\n\t\t\t\t\t\t'YXZ', // -> ZXY extrinsic\n\t\t\t\t\t\t'XYZ'];\n\n\t\t\t\t\t\tif (order === 6) {\n\n\t\t\t\t\t\t\t\t\tconsole.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');\n\t\t\t\t\t\t\t\t\treturn enums[0];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn enums[order];\n\t\t\t}\n\n\t\t\t// Parses comma separated list of numbers and returns them an array.\n\t\t\t// Used internally by the TextParser\n\t\t\tfunction parseNumberArray(value) {\n\n\t\t\t\t\t\tvar array = value.split(',').map(function (val) {\n\n\t\t\t\t\t\t\t\t\treturn parseFloat(val);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn array;\n\t\t\t}\n\n\t\t\tfunction convertArrayBufferToString(buffer, from, to) {\n\n\t\t\t\t\t\tif (from === undefined) from = 0;\n\t\t\t\t\t\tif (to === undefined) to = buffer.byteLength;\n\n\t\t\t\t\t\treturn THREE.LoaderUtils.decodeText(new Uint8Array(buffer, from, to));\n\t\t\t}\n\n\t\t\tfunction append(a, b) {\n\n\t\t\t\t\t\tfor (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {\n\n\t\t\t\t\t\t\t\t\ta[j] = b[i];\n\t\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tfunction slice(a, b, from, to) {\n\n\t\t\t\t\t\tfor (var i = from, j = 0; i < to; i++, j++) {\n\n\t\t\t\t\t\t\t\t\ta[j] = b[i];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn a;\n\t\t\t}\n\n\t\t\t// inject array a2 into array a1 at index\n\t\t\tfunction inject(a1, index, a2) {\n\n\t\t\t\t\t\treturn a1.slice(0, index).concat(a2).concat(a1.slice(index));\n\t\t\t}\n\n\t\t\treturn FBXLoader;\n}();\n\n//# sourceURL=webpack://clouds/./js/lib/loaders/FBXLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/OBJLoader.js":
/*!*************************************!*\
  !*** ./js/lib/loaders/OBJLoader.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\n\nTHREE.OBJLoader = function () {\n\n\t\t\t\t// o object_name | g group_name\n\t\t\t\tvar object_pattern = /^[og]\\s*(.+)?/;\n\t\t\t\t// mtllib file_reference\n\t\t\t\tvar material_library_pattern = /^mtllib /;\n\t\t\t\t// usemtl material_name\n\t\t\t\tvar material_use_pattern = /^usemtl /;\n\n\t\t\t\tfunction ParserState() {\n\n\t\t\t\t\t\t\t\tvar state = {\n\t\t\t\t\t\t\t\t\t\t\t\tobjects: [],\n\t\t\t\t\t\t\t\t\t\t\t\tobject: {},\n\n\t\t\t\t\t\t\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\t\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\t\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\t\t\t\t\t\t\tuvs: [],\n\n\t\t\t\t\t\t\t\t\t\t\t\tmaterialLibraries: [],\n\n\t\t\t\t\t\t\t\t\t\t\t\tstartObject: function (name, fromDeclaration) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If the current object (initial from reset) is not from a g/o declaration in the parsed\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// file. We need to use it for the first parsed g/o to keep things in sync.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.object && this.object.fromDeclaration === false) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object.name = name;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object.fromDeclaration = fromDeclaration !== false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.object && typeof this.object._finalize === 'function') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object._finalize(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfromDeclaration: fromDeclaration !== false,\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgeometry: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvertices: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnormals: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolors: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tuvs: []\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterials: [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsmooth: true,\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstartMaterial: function (name, libraries) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar previous = this._finalize(false);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// New usemtl declaration overwrites an inherited material, except if faces were declared\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// after the material, then it must be preserved for proper MultiMaterial continuation.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (previous && (previous.inherited || previous.groupCount <= 0)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.materials.splice(previous.index, 1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar material = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex: this.materials.length,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: name || '',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsmooth: previous !== undefined ? previous.smooth : this.smooth,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupStart: previous !== undefined ? previous.groupEnd : 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupEnd: -1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupCount: -1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinherited: false,\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclone: function (index) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar cloned = {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tindex: typeof index === 'number' ? index : this.index,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: this.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmtllib: this.mtllib,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsmooth: this.smooth,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupStart: 0,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupEnd: -1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgroupCount: -1,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tinherited: false\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcloned.clone = this.clone.bind(cloned);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn cloned;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.materials.push(material);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn material;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcurrentMaterial: function () {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.materials.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.materials[this.materials.length - 1];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t_finalize: function (end) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lastMultiMaterial = this.currentMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlastMultiMaterial.inherited = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Ignore objects tail materials if no face declarations followed them before a new o/g started.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (end && this.materials.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var mi = this.materials.length - 1; mi >= 0; mi--) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.materials[mi].groupCount <= 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.materials.splice(mi, 1);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Guarantee at least one empty material, this makes the creation later more straight forward.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (end && this.materials.length === 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.materials.push({\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tname: '',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsmooth: this.smooth\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn lastMultiMaterial;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Inherit previous objects material.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Spec tells us that a declared material must be set to all objects until a new material is declared.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// If a usemtl declaration is encountered while this new object is being parsed, it will\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// overwrite the inherited material. Exception being that there was already face declarations\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// to the inherited material, then it will be preserved for proper MultiMaterial continuation.\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar declared = previousMaterial.clone(0);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdeclared.inherited = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object.materials.push(declared);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.objects.push(this.object);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\tfinalize: function () {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.object && typeof this.object._finalize === 'function') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object._finalize(true);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\tparseVertexIndex: function (value, len) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 3) * 3;\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\tparseNormalIndex: function (value, len) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 3) * 3;\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\tparseUVIndex: function (value, len) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar index = parseInt(value, 10);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn (index >= 0 ? index - 1 : index + len / 2) * 2;\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddVertex: function (a, b, c) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddVertexPoint: function (a) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddVertexLine: function (a) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.vertices;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.vertices;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddNormal: function (a, b, c) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.normals;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.normals;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddColor: function (a, b, c) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.colors;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.colors;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1], src[a + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[b + 0], src[b + 1], src[b + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[c + 0], src[c + 1], src[c + 2]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddUV: function (a, b, c) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.uvs;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[b + 0], src[b + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[c + 0], src[c + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddUVLine: function (a) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar src = this.uvs;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar dst = this.object.geometry.uvs;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdst.push(src[a + 0], src[a + 1]);\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddFace: function (a, b, c, ua, ub, uc, na, nb, nc) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar ia = this.parseVertexIndex(a, vLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar ib = this.parseVertexIndex(b, vLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar ic = this.parseVertexIndex(c, vLen);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addVertex(ia, ib, ic);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (ua !== undefined && ua !== '') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar uvLen = this.uvs.length;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tia = this.parseUVIndex(ua, uvLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tib = this.parseUVIndex(ub, uvLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tic = this.parseUVIndex(uc, uvLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addUV(ia, ib, ic);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (na !== undefined && na !== '') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Normals are many times the same. If so, skip function call and parseInt.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar nLen = this.normals.length;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tia = this.parseNormalIndex(na, nLen);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tib = na === nb ? ia : this.parseNormalIndex(nb, nLen);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tic = na === nc ? ia : this.parseNormalIndex(nc, nLen);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addNormal(ia, ib, ic);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.colors.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addColor(ia, ib, ic);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddPointGeometry: function (vertices) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object.geometry.type = 'Points';\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vLen = this.vertices.length;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var vi = 0, l = vertices.length; vi < l; vi++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addVertexPoint(this.parseVertexIndex(vertices[vi], vLen));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t\t\t\t\taddLineGeometry: function (vertices, uvs) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.object.geometry.type = 'Line';\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vLen = this.vertices.length;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar uvLen = this.uvs.length;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var vi = 0, l = vertices.length; vi < l; vi++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var uvi = 0, l = uvs.length; uvi < l; uvi++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tstate.startObject('', false);\n\n\t\t\t\t\t\t\t\treturn state;\n\t\t\t\t}\n\n\t\t\t\t//\n\n\t\t\t\tfunction OBJLoader(manager) {\n\n\t\t\t\t\t\t\t\tthis.manager = manager !== undefined ? manager : THREE.DefaultLoadingManager;\n\n\t\t\t\t\t\t\t\tthis.materials = null;\n\t\t\t\t}\n\n\t\t\t\tOBJLoader.prototype = {\n\n\t\t\t\t\t\t\t\tconstructor: OBJLoader,\n\n\t\t\t\t\t\t\t\tload: function (url, onLoad, onProgress, onError) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar scope = this;\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar loader = new THREE.FileLoader(scope.manager);\n\t\t\t\t\t\t\t\t\t\t\t\tloader.setPath(this.path);\n\t\t\t\t\t\t\t\t\t\t\t\tloader.load(url, function (text) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonLoad(scope.parse(text));\n\t\t\t\t\t\t\t\t\t\t\t\t}, onProgress, onError);\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\tsetPath: function (value) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.path = value;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\tsetMaterials: function (materials) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tthis.materials = materials;\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\tparse: function (text) {\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.time('OBJLoader');\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar state = new ParserState();\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (text.indexOf('\\r\\n') !== -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// This is faster than String.split with regex that splits on both\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttext = text.replace(/\\r\\n/g, '\\n');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (text.indexOf('\\\\\\n') !== -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// join lines separated by a line continuation character (\\)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttext = text.replace(/\\\\\\n/g, '');\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar lines = text.split('\\n');\n\t\t\t\t\t\t\t\t\t\t\t\tvar line = '',\n\t\t\t\t\t\t\t\t\t\t\t\t    lineFirstChar = '';\n\t\t\t\t\t\t\t\t\t\t\t\tvar lineLength = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tvar result = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Faster to just trim left side of the line. Use if available.\n\t\t\t\t\t\t\t\t\t\t\t\tvar trimLeft = typeof ''.trimLeft === 'function';\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = lines.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tline = lines[i];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tline = trimLeft ? line.trimLeft() : line.trim();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlineLength = line.length;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lineLength === 0) continue;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlineFirstChar = line.charAt(0);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// @todo invoke passed in handler if any\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lineFirstChar === '#') continue;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (lineFirstChar === 'v') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar data = line.split(/\\s+/);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tswitch (data[0]) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (data.length === 8) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'vn':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcase 'vt':\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.uvs.push(parseFloat(data[1]), parseFloat(data[2]));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (lineFirstChar === 'f') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lineData = line.substr(1).trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vertexData = lineData.split(/\\s+/);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar faceVertices = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Parse the face vertex data into an easy to work with format\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 0, jl = vertexData.length; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vertex = vertexData[j];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (vertex.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar vertexParts = vertex.split('/');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfaceVertices.push(vertexParts);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Draw an edge between the first vertex and all subsequent vertices to form an n-gon\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar v1 = faceVertices[0];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var j = 1, jl = faceVertices.length - 1; j < jl; j++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar v2 = faceVertices[j];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar v3 = faceVertices[j + 1];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (lineFirstChar === 'l') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lineParts = line.substring(1).trim().split(\" \");\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lineVertices = [],\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t    lineUVs = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (line.indexOf(\"/\") === -1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlineVertices = lineParts;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var li = 0, llen = lineParts.length; li < llen; li++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar parts = lineParts[li].split(\"/\");\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (parts[0] !== \"\") lineVertices.push(parts[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (parts[1] !== \"\") lineUVs.push(parts[1]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.addLineGeometry(lineVertices, lineUVs);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (lineFirstChar === 'p') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar lineData = line.substr(1).trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar pointData = lineData.split(\" \");\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.addPointGeometry(pointData);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if ((result = object_pattern.exec(line)) !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// o object_name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// or\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// g group_name\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// var name = result[ 0 ].substr( 1 ).trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar name = (\" \" + result[0].substr(1).trim()).substr(1);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.startObject(name);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (material_use_pattern.test(line)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// material\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.object.startMaterial(line.substring(7).trim(), state.materialLibraries);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (material_library_pattern.test(line)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// mtl file\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.materialLibraries.push(line.substring(7).trim());\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (lineFirstChar === 's') {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tresult = line.split(' ');\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// smooth shading\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// @todo Handle files that have varying smooth values for a set of faces inside one geometry,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// but does not define a usemtl for each face set.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// This should be detected and a dummy material created (later MultiMaterial and geometry groups).\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// This requires some care to not create extra material on each smooth value for \"normal\" obj files.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// where explicit usemtl defines geometry groups.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Example asset: examples/models/obj/cerberus/Cerberus.obj\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/*\r\n                     * http://paulbourke.net/dataformats/obj/\r\n                     * or\r\n                     * http://www.cs.utah.edu/~boulos/cs3505/obj_spec.pdf\r\n                     *\r\n                     * From chapter \"Grouping\" Syntax explanation \"s group_number\":\r\n                     * \"group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.\r\n                     * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form\r\n                     * surfaces, smoothing groups are either turned on or off; there is no difference between values greater\r\n                     * than 0.\"\r\n                     */\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (result.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar value = result[1].trim().toLowerCase();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.object.smooth = value !== '0' && value !== 'off';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ZBrush can produce \"s\" lines #11707\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tstate.object.smooth = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar material = state.object.currentMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (material) material.smooth = state.object.smooth;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Handle null terminated files without exception\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (line === '\\0') continue;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthrow new Error('THREE.OBJLoader: Unexpected line: \"' + line + '\"');\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tstate.finalize();\n\n\t\t\t\t\t\t\t\t\t\t\t\tvar container = new THREE.Group();\n\t\t\t\t\t\t\t\t\t\t\t\tcontainer.materialLibraries = [].concat(state.materialLibraries);\n\n\t\t\t\t\t\t\t\t\t\t\t\tfor (var i = 0, l = state.objects.length; i < l; i++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar object = state.objects[i];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar geometry = object.geometry;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar materials = object.materials;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar isLine = geometry.type === 'Line';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar isPoints = geometry.type === 'Points';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar hasVertexColors = false;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Skip o/g line declarations that did not follow with any faces\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.vertices.length === 0) continue;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar buffergeometry = new THREE.BufferGeometry();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.addAttribute('position', new THREE.Float32BufferAttribute(geometry.vertices, 3));\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.normals.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.addAttribute('normal', new THREE.Float32BufferAttribute(geometry.normals, 3));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.computeVertexNormals();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.colors.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thasVertexColors = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.addAttribute('color', new THREE.Float32BufferAttribute(geometry.colors, 3));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (geometry.uvs.length > 0) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.addAttribute('uv', new THREE.Float32BufferAttribute(geometry.uvs, 2));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Create materials\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar createdMaterials = [];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar material = undefined;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (this.materials !== null) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = this.materials.create(sourceMaterial.name);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (isLine && material && !(material instanceof THREE.LineBasicMaterial)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar materialLine = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call(materialLine, material);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterialLine.color.copy(material.color);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterialLine.lights = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = materialLine;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (isPoints && material && !(material instanceof THREE.PointsMaterial)) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar materialPoints = new THREE.PointsMaterial({ size: 10, sizeAttenuation: false });\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tTHREE.Material.prototype.copy.call(materialPoints, material);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterialPoints.color.copy(material.color);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterialPoints.map = material.map;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterialPoints.lights = false;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = materialPoints;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (!material) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.LineBasicMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.PointsMaterial({ size: 1, sizeAttenuation: false });\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial = new THREE.MeshPhongMaterial();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial.name = sourceMaterial.name;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial.flatShading = sourceMaterial.smooth ? false : true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmaterial.vertexColors = hasVertexColors ? THREE.VertexColors : THREE.NoColors;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcreatedMaterials.push(material);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Create mesh\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar mesh;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (createdMaterials.length > 1) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfor (var mi = 0, miLen = materials.length; mi < miLen; mi++) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvar sourceMaterial = materials[mi];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffergeometry.addGroup(sourceMaterial.groupStart, sourceMaterial.groupCount, mi);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.LineSegments(buffergeometry, createdMaterials);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.Points(buffergeometry, createdMaterials);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.Mesh(buffergeometry, createdMaterials);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (isLine) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.LineSegments(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (isPoints) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.Points(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh = new THREE.Mesh(buffergeometry, createdMaterials[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmesh.name = object.name;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontainer.add(mesh);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tconsole.timeEnd('OBJLoader');\n\n\t\t\t\t\t\t\t\t\t\t\t\treturn container;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\treturn OBJLoader;\n}();\n\n//# sourceURL=webpack://clouds/./js/lib/loaders/OBJLoader.js?");

/***/ }),

/***/ "./js/lib/loaders/index.js":
/*!*********************************!*\
  !*** ./js/lib/loaders/index.js ***!
  \*********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _FBXLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FBXLoader.js */ \"./js/lib/loaders/FBXLoader.js\");\n/* harmony import */ var _FBXLoader_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_FBXLoader_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _OBJLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./OBJLoader.js */ \"./js/lib/loaders/OBJLoader.js\");\n/* harmony import */ var _OBJLoader_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_OBJLoader_js__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n//# sourceURL=webpack://clouds/./js/lib/loaders/index.js?");

/***/ }),

/***/ "./js/main.js":
/*!********************!*\
  !*** ./js/main.js ***!
  \********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_logic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/logic */ \"./js/modules/logic.js\");\n/* harmony import */ var _modules_renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/renderer */ \"./js/modules/renderer.js\");\n/* harmony import */ var _ui_control_surface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui/control_surface */ \"./js/ui/control_surface.js\");\n/* harmony import */ var _overlay_menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./overlay/menu */ \"./js/overlay/menu.js\");\n/** App init and main loop. */\n\n\n\n\n\n\nclass App {\n  constructor() {\n    // init\n    this.logic = new _modules_logic__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n    this.renderer = new _modules_renderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this);\n    this.controlSurface = new _ui_control_surface__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n    this.menu = new _overlay_menu__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n\n    // timing\n    this.time = {\n      now: performance.now(),\n      maxDelta: 0.1\n    };\n\n    // run\n    this.bindEvents();\n    this.active = true;\n    this.loop();\n  }\n\n  bindEvents() {\n    // catch resize lag on fullscreen change\n    window.addEventListener('resize', () => {\n      if (window.innerHeight === screen.height && !this.isFullscreen) {\n        this.isFullscreen = true;\n        setTimeout(() => {\n          window.dispatchEvent(new Event('resize'));\n        }, 50);\n      }\n      this.isFullscreen = false;\n    });\n\n    // call initial resize\n    window.dispatchEvent(new Event('resize'));\n  }\n\n  loop() {\n    requestAnimationFrame(() => {\n      this.loop();\n    });\n    if (this.active) {\n      const t = performance.now();\n      const delta = Math.min(this.time.maxDelta, (t - this.time.now) / 1000);\n      this.time.now = t;\n      this.logic.update(delta);\n      this.renderer.render(delta);\n      this.logic.draw(delta);\n    }\n  }\n}\n\nwindow.onload = () => {\n  const app = new App();\n};\n\n//# sourceURL=webpack://clouds/./js/main.js?");

/***/ }),

/***/ "./js/modules/camera.js":
/*!******************************!*\
  !*** ./js/modules/camera.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./js/config.js\");\n/** First-person camera. */\n\n\n\nclass Camera {\n  constructor(root) {\n    this.root = root;\n    this.position = root.player.position;\n    this.rotation = root.player.rotation;\n    this.height = root.player.height;\n    //this.target = new THREE.Vector3();\n    this.fov = 65;\n    this.aspectRatio = 1.0;\n    this.offset = 0.1;\n    this.camera = new THREE.PerspectiveCamera(this.fov, this.aspectRatio, 0.1, 2000000);\n    this.camera.up = new THREE.Vector3(0, 1, 0);\n    this.camera.rotation.order = 'YXZ';\n    this.resize();\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n  }\n\n  resize() {\n    const w = Math.floor(_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width / 100 * window.innerWidth);\n    const h = Math.floor(_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].height / 100 * window.innerHeight);\n    this.aspectRatio = w / h;\n    this.camera.aspect = this.aspectRatio;\n    this.camera.updateProjectionMatrix();\n  }\n\n  update(delta) {\n    const offsetXZ = this.offset - this.offset * Math.abs(Math.sin(this.rotation.y));\n    const offsetY = this.offset;\n    const y = this.position.y + this.height;\n    this.camera.position.set(this.position.x, this.position.y + this.height, this.position.z);\n    this.camera.rotation.y = this.rotation.x + Math.PI;\n    this.camera.rotation.x = this.rotation.y;\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Camera);\n\n//# sourceURL=webpack://clouds/./js/modules/camera.js?");

/***/ }),

/***/ "./js/modules/canvas_2d.js":
/*!*********************************!*\
  !*** ./js/modules/canvas_2d.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../config */ \"./js/config.js\");\n/** 2D Canvas overlays */\n\n\n\nclass Canvas2D {\n  constructor() {\n    this.domElement = document.querySelector('#canvas-target-2d');\n    this.cvs = this.domElement;\n    this.ctx = this.cvs.getContext('2d');\n\n    // dom\n    this.resize();\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n  }\n\n  clear() {\n    this.ctx.clearRect(0, 0, this.cvs.width, this.cvs.height);\n  }\n\n  setStyle() {\n    this.ctx.fillStyle = '#fff';\n    this.ctx.strokeStyle = '#fff';\n    this.ctx.lineWidth = 1;\n  }\n\n  resize() {\n    this.cvs.width = Math.floor(_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].width / 100 * window.innerWidth);\n    this.cvs.height = Math.floor(_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].height / 100 * window.innerHeight);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Canvas2D);\n\n//# sourceURL=webpack://clouds/./js/modules/canvas_2d.js?");

/***/ }),

/***/ "./js/modules/logic.js":
/*!*****************************!*\
  !*** ./js/modules/logic.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./player */ \"./js/modules/player.js\");\n/* harmony import */ var _camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./camera */ \"./js/modules/camera.js\");\n/* harmony import */ var _world__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./world */ \"./js/modules/world.js\");\n/* harmony import */ var _canvas_2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./canvas_2d */ \"./js/modules/canvas_2d.js\");\n/** Game logic. */\n\n\n\n\n\n\nclass Logic {\n  constructor() {\n    this.scene = new THREE.Scene();\n    this.colliderSystem = new Collider.System();\n    this.player = new _player__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this);\n    this.camera = new _camera__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this);\n    this.world = new _world__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this);\n    this.canvas2D = new _canvas_2d__WEBPACK_IMPORTED_MODULE_3__[\"default\"]();\n\n    // temp\n    //const box = new THREE.BoxBufferGeometry(10, 50, 10);\n    //const mat = new THREE.MeshPhysicalMaterial({color: 0x888888, metalness: 0, roughness: 0.05});\n    //const floor = new THREE.Mesh(box, mat);\n    //floor.position.set(0, -24, 0);\n    //this.scene.add(floor);\n    //this.colliderSystem.add(floor);\n  }\n\n  update(delta) {\n    this.world.update(delta);\n    this.player.update(delta);\n    this.camera.update(delta);\n  }\n\n  draw(delta) {\n    this.canvas2D.clear();\n    this.canvas2D.setStyle();\n    this.world.draw(this.canvas2D.ctx);\n    if (this.player.noclip) {\n      this.canvas2D.ctx.fillText('[noclip]', 20, this.canvas2D.cvs.height - 20);\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Logic);\n\n//# sourceURL=webpack://clouds/./js/modules/logic.js?");

/***/ }),

/***/ "./js/modules/material/cloud_material.js":
/*!***********************************************!*\
  !*** ./js/modules/material/cloud_material.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Custom cloud shader */\n\nconst CloudMaterial = new THREE.ShaderMaterial({\n  uniforms: {\n    uTime: { value: 1.0 },\n    uDetailLevel: { value: 2.0 } // 1, 2, 3\n  },\n  vertexShader: `\n    varying vec2 vUV;\n\n    void main() {\n      vUV = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  `,\n  fragmentShader: `\n    const float sqrt_half = 0.7071;\n    const float sqrt2 = 1.41421;\n    const float sqrt2_2 = 2.82842;\n    const float const289 = 0.00346020761; //= 1.0 / 289.0\n    varying vec2 vUV;\n    uniform float uTime;\n    uniform float uDetailLevel;\n\n    // height normals\n    vec3 computeNormal(vec3 a, vec3 b, vec3 c, float height) {\n      vec3 ab = vec3(1.0, (b.y - a.y) * height, 0.0);\n      vec3 ac = vec3(0.0, (c.y - a.y) * height, 1.0);\n      return cross(normalize(ab), normalize(ac));\n    }\n\n    // smoothing\n    vec3 mod289(vec3 x) { return x - floor(x * const289) * 289.0; }\n    vec4 mod289(vec4 x) { return x - floor(x * const289) * 289.0; }\n    vec4 permute(vec4 x) { return mod289(((x * 34.0) + 1.0) * x); }\n    vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n    vec3 fade(vec3 t) { return t * t * t * (t * (t * 6.0 - 15.0) + 10.0); }\n\n    // perlin noise\n    float noise(vec3 v) {\n        vec3 i0 = mod289(floor(v)), i1 = mod289(i0 + vec3(1.0));\n        vec3 f0 = fract(v), f1 = f0 - vec3(1.0), f = fade(f0);\n        vec4 ix = vec4(i0.x, i1.x, i0.x, i1.x), iy = vec4(i0.yy, i1.yy);\n        vec4 iz0 = i0.zzzz, iz1 = i1.zzzz;\n        vec4 ixy = permute(permute(ix) + iy), ixy0 = permute(ixy + iz0), ixy1 = permute(ixy + iz1);\n        vec4 gx0 = ixy0 * (1.0 / 7.0), gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n        vec4 gx1 = ixy1 * (1.0 / 7.0), gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n        gx0 = fract(gx0); gx1 = fract(gx1);\n        vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0), sz0 = step(gz0, vec4(0.0));\n        vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1), sz1 = step(gz1, vec4(0.0));\n        gx0 -= sz0 * (step(0.0, gx0) - 0.5); gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n        gx1 -= sz1 * (step(0.0, gx1) - 0.5); gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n        vec3 g0 = vec3(gx0.x, gy0.x, gz0.x), g1 = vec3(gx0.y, gy0.y, gz0.y),\n          g2 = vec3(gx0.z, gy0.z, gz0.z), g3 = vec3(gx0.w, gy0.w, gz0.w),\n          g4 = vec3(gx1.x, gy1.x, gz1.x), g5 = vec3(gx1.y, gy1.y, gz1.y),\n          g6 = vec3(gx1.z, gy1.z, gz1.z), g7 = vec3(gx1.w, gy1.w, gz1.w);\n        vec4 norm0 = taylorInvSqrt(vec4(dot(g0, g0), dot(g2, g2), dot(g1, g1), dot(g3, g3)));\n        vec4 norm1 = taylorInvSqrt(vec4(dot(g4, g4), dot(g6, g6), dot(g5, g5), dot(g7, g7)));\n        g0 *= norm0.x; g2 *= norm0.y; g1 *= norm0.z; g3 *= norm0.w;\n        g4 *= norm1.x; g6 *= norm1.y; g5 *= norm1.z; g7 *= norm1.w;\n        vec4 nz = mix(vec4(dot(g0, vec3(f0.x, f0.y, f0.z)), dot(g1, vec3(f1.x, f0.y, f0.z)),\n          dot(g2, vec3(f0.x, f1.y, f0.z)), dot(g3, vec3(f1.x, f1.y, f0.z))),\n          vec4(dot(g4, vec3(f0.x, f0.y, f1.z)), dot(g5, vec3(f1.x, f0.y, f1.z)),\n            dot(g6, vec3(f0.x, f1.y, f1.z)), dot(g7, vec3(f1.x, f1.y, f1.z))), f.z);\n        return 2.4 * mix(mix(nz.x, nz.z, f.y), mix(nz.y, nz.w, f.y), f.x);\n    }\n\n    float turbulenceHigh(vec3 v) {\n      float f = 0.0;\n      float s = 1.0;\n      for (int i=0; i<7; ++i) {\n        f += abs(noise(s * v)) / s;\n        s *= 2.0;\n        v = vec3(0.866 * v.x + 0.5 * v.z, v.y + 100.0, 0.866 * v.z - 0.5 * v.x);\n      }\n      return f;\n    }\n\n    float turbulenceMid(vec3 v) {\n      float f = 0.0;\n      float s = 1.0;\n      for (int i=0; i<5; ++i) {\n        f += abs(noise(s * v)) / s;\n        s *= 2.0;\n        v = vec3(0.866 * v.x + 0.5 * v.z, v.y + 100.0, 0.866 * v.z - 0.5 * v.x);\n      }\n      return f;\n    }\n\n    float turbulenceLow(vec3 v) {\n      float f = 0.0;\n      float s = 1.0;\n      for (int i=0; i<2; ++i) {\n        f += abs(noise(v * s)) / s;\n        s *= 2.0;\n        v = vec3(0.866 * v.x + 0.5 * v.z, v.y + 100.0, 0.866 * v.z - 0.5 * v.x);\n      }\n      return f;\n    }\n\n    vec3 clouds(float x, float y, float t, float detail) {\n      vec3 v = vec3(x, y, t);\n      float f = detail == 3.0 ? turbulenceHigh(v) : detail == 2.0 ? turbulenceMid(v) : turbulenceLow(v);\n      return vec3(noise(vec3(0.5, 0.5, f) * 0.7)) + vec3(1.0, 1.0, 1.0);\n    }\n\n    void main() {\n      float speed = 0.015;\n      float offset = uTime * speed * -0.5;\n      float phase = uTime * speed;\n      float x = vUV.x * 5.0 + offset;\n      float y = vUV.y * 5.0;\n      vec3 colour = clouds(x, y, phase, uDetailLevel);\n\n      // calc normals\n      float res = 0.1;\n      float cloudHeight = 50.0;\n      float detail = max(1.0, uDetailLevel - 1.0);\n      vec3 p1 = clouds(x + res, y, phase, detail);\n      vec3 p2 = clouds(x, y + res, phase, detail);\n      vec3 norm = computeNormal(colour, p1, p2, cloudHeight);\n      float light = dot(norm, vec3(0.0, 1.0, 0.0)) - 0.5;\n\n      // result\n\t\t\tvec3 prussian = vec3(0.0, 0.192, 0.325);\n      float alpha = 1.0 - min(1.0, sqrt(pow(0.5 - vUV.x, 2.0) + pow(0.5 - vUV.y, 2.0)) / 0.5);\n      gl_FragColor = vec4(colour + prussian + light * 0.5, colour.x * alpha);\n    }\n  `\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CloudMaterial);\n\n//# sourceURL=webpack://clouds/./js/modules/material/cloud_material.js?");

/***/ }),

/***/ "./js/modules/player.js":
/*!******************************!*\
  !*** ./js/modules/player.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_maths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/maths */ \"./js/utils/maths.js\");\n/**\r\n ** Handle user input and move/ rotate player position.\r\n **/\n\n\n\nclass Player {\n  constructor(root) {\n    this.root = root;\n\n    // set position\n    this.position = new THREE.Vector3(0, 1, 0);\n    this.rotation = new THREE.Vector2();\n    this.motion = new THREE.Vector3();\n    this.target = {\n      position: this.position.clone(),\n      rotation: this.rotation.clone(),\n      motion: this.motion.clone()\n    };\n\n    // bind collision system\n    this.collider = new Collider.Point({\n      system: this.root.colliderSystem,\n      position: this.target.position,\n      motion: this.motion,\n      gravity: 18,\n      floor: -25\n    });\n\n    // physical attributes\n    this.speed = 6;\n    this.rotationSpeed = Math.PI * 0.5;\n    this.jump = 8;\n    this.jumpSpeedMultiplier = 0.25;\n    this.height = 2;\n    this.falling = false;\n    this.fallTime = 0;\n    this.fallTimeThreshold = 0.2;\n    this.minPitch = Math.PI * -0.2;\n    this.maxPitch = Math.PI * 0.25;\n    this.adjust = { slow: 0.05, normal: 0.1, fast: 0.125, maximum: 0.3 };\n    this.noclip = false;\n    this.noclipSpeed = 30;\n\n    // input\n    this.keys = { disabled: false };\n  }\n\n  move(delta) {\n    // key input to motion\n    if (this.keys.left || this.keys.right) {\n      const rot = (this.keys.left ? 1 : 0) + (this.keys.right ? -1 : 0);\n      this.target.rotation.x += rot * this.rotationSpeed * delta;\n    }\n\n    if (this.keys.up || this.keys.down) {\n      const speed = this.noclip ? this.noclipSpeed * (1 - Math.abs(Math.sin(this.target.rotation.y))) : this.speed;\n      const dir = (this.keys.up ? 1 : 0) + (this.keys.down ? -1 : 0);\n      this.target.motion.x = Math.sin(this.rotation.x) * speed * dir;\n      this.target.motion.z = Math.cos(this.rotation.x) * speed * dir;\n    } else {\n      this.target.motion.x = 0;\n      this.target.motion.z = 0;\n    }\n\n    if (this.keys.jump) {\n      if (this.motion.y == 0 || this.fallTime < this.fallTimeThreshold) {\n        this.motion.y = this.jump;\n        this.fallTime = this.fallTimeThreshold;\n      }\n    }\n\n    // decide if falling\n    this.falling = this.motion.y != 0;\n    this.fallTime = this.falling ? this.fallTime + delta : 0;\n\n    // noclip\n    if (this.noclip) {\n      this.falling = false;\n      if (this.keys.up || this.keys.down) {\n        const d = (this.keys.up ? 1 : 0) + (this.keys.down ? -1 : 0);\n        this.target.motion.y = Math.sin(this.target.rotation.y) * d * this.noclipSpeed;\n      } else {\n        this.target.motion.y = 0;\n      }\n      this.motion.y = this.target.motion.y;\n    }\n\n    // reduce speed if falling\n    if (!this.falling) {\n      this.motion.x = this.target.motion.x;\n      this.motion.z = this.target.motion.z;\n    } else {\n      this.motion.x = Object(_utils_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.motion.x, this.target.motion.x, this.jumpSpeedMultiplier);\n      this.motion.z = Object(_utils_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.motion.z, this.target.motion.z, this.jumpSpeedMultiplier);\n    }\n  }\n\n  setRotation(pitch, yaw) {\n    this.target.rotation.y = pitch;\n    this.target.rotation.x = yaw;\n  }\n\n  update(delta) {\n    // move\n    if (!this.keys.disabled) {\n      this.move(delta);\n      if (!this.noclip) {\n        this.collider.collide(delta);\n      } else {\n        this.target.position.x += this.motion.x * delta;\n        this.target.position.y += this.motion.y * delta;\n        this.target.position.z += this.motion.z * delta;\n      }\n      this.position.x = Object(_utils_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.position.x, this.target.position.x, this.adjust.maximum);\n      this.position.y = Object(_utils_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.position.y, this.target.position.y, this.adjust.maximum);\n      this.position.z = Object(_utils_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.position.z, this.target.position.z, this.adjust.maximum);\n    }\n\n    // rotate\n    this.rotation.x += Object(_utils_maths__WEBPACK_IMPORTED_MODULE_0__[\"MinAngleBetween\"])(this.rotation.x, this.target.rotation.x) * this.adjust.normal;\n    this.rotation.y = Object(_utils_maths__WEBPACK_IMPORTED_MODULE_0__[\"Blend\"])(this.rotation.y, this.target.rotation.y, this.adjust.normal);\n  }\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Player);\n\n//# sourceURL=webpack://clouds/./js/modules/player.js?");

/***/ }),

/***/ "./js/modules/portal_handler.js":
/*!**************************************!*\
  !*** ./js/modules/portal_handler.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ui_portal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ui/portal */ \"./js/ui/portal.js\");\n/** Load and maintain portals */\n\n\n\nclass PortalHandler {\n  constructor(root) {\n    this.root = root;\n    this.createPortals();\n  }\n\n  createPortals() {\n    const size = new THREE.Vector3(4, 8, 4);\n\n    // main <-> octopus\n    const from1 = new THREE.Box3();\n    const to1 = new THREE.Box3();\n    from1.setFromCenterAndSize(new THREE.Vector3(8, -2, 12), size.clone());\n    to1.setFromCenterAndSize(new THREE.Vector3(8, -2, -38), size.clone());\n    const from2 = new THREE.Box3();\n    const to2 = new THREE.Box3();\n    from2.setFromCenterAndSize(new THREE.Vector3(4, -1, -38), size.clone());\n    to2.setFromCenterAndSize(new THREE.Vector3(4, -1, 12), size.clone());\n\n    // library <-> octopus\n    const from3 = new THREE.Box3();\n    const to3 = new THREE.Box3();\n    from3.setFromCenterAndSize(new THREE.Vector3(-40, 2, -12), size.clone());\n    to3.setFromCenterAndSize(new THREE.Vector3(-40, 2, -62), size.clone());\n    const from4 = new THREE.Box3();\n    const to4 = new THREE.Box3();\n    from4.setFromCenterAndSize(new THREE.Vector3(-44, 2, -62), size.clone());\n    to4.setFromCenterAndSize(new THREE.Vector3(-44, 2, -12), size.clone());\n\n    // main <-> observatory\n    const from5 = new THREE.Box3();\n    const to5 = new THREE.Box3();\n    from5.setFromCenterAndSize(new THREE.Vector3(-8, 7, 12), size.clone());\n    to5.setFromCenterAndSize(new THREE.Vector3(-8, 7, -88), size.clone());\n    const from6 = new THREE.Box3();\n    const to6 = new THREE.Box3();\n    from6.setFromCenterAndSize(new THREE.Vector3(-4, 4, -88), size.clone());\n    to6.setFromCenterAndSize(new THREE.Vector3(-4, 4, 12), size.clone());\n\n    // observatory <-> garden\n    const from7 = new THREE.Box3();\n    const to7 = new THREE.Box3();\n    from7.setFromCenterAndSize(new THREE.Vector3(40, 4, -108), size.clone());\n    to7.setFromCenterAndSize(new THREE.Vector3(40, 4, -158), size.clone());\n    const from8 = new THREE.Box3();\n    const to8 = new THREE.Box3();\n    from8.setFromCenterAndSize(new THREE.Vector3(40, 7, -154), size.clone());\n    to8.setFromCenterAndSize(new THREE.Vector3(40, 7, -104), size.clone());\n\n    // garden -> library\n    const from9 = new THREE.Box3();\n    const to9 = new THREE.Box3();\n    from9.setFromCenterAndSize(new THREE.Vector3(6, -12, -147), size.clone());\n    to9.setFromCenterAndSize(new THREE.Vector3(-34, 9, 0), size.clone());\n\n    // create portals\n    this.portals = [[from1, to1], [from2, to2], [from3, to3], [from4, to4], [from5, to5], [from6, to6], [from7, to7], [from8, to8], [from9, to9]].map(e => {\n      return new _ui_portal__WEBPACK_IMPORTED_MODULE_0__[\"default\"](e[0], e[1], {\n        onTeleport: () => {},\n        showBoxes: true,\n        scene: this.root.scene\n      });\n    });\n  }\n\n  update() {\n    for (let i = 0, lim = this.portals.length; i < lim; ++i) {\n      this.portals[i].update(this.root.player);\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PortalHandler);\n\n//# sourceURL=webpack://clouds/./js/modules/portal_handler.js?");

/***/ }),

/***/ "./js/modules/renderer.js":
/*!********************************!*\
  !*** ./js/modules/renderer.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/glsl */ \"./js/lib/glsl/index.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../config */ \"./js/config.js\");\n/** Three.js/ webgl renderer. */\n\n\n\n\nclass Renderer {\n  constructor(root) {\n    this.root = root;\n\n    // three.js setup\n    this.domElement = document.querySelector('#canvas-target');\n    this.renderer = new THREE.WebGLRenderer({ canvas: this.domElement });\n    this.renderer.setClearColor(0x0, 1);\n    this.renderer.gammaInput = true;\n    this.renderer.gammaOutput = true;\n    this.renderer.gammaFactor = 2.0;\n    this.width = Math.floor(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].width / 100 * window.innerWidth);\n    this.height = Math.floor(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].height / 100 * window.innerHeight);\n    this.size = new THREE.Vector2(this.width, this.height);\n\n    // render passes\n    const strength = 0.5;\n    const radius = 0.125;\n    const threshold = 0.96;\n    this.passRender = new THREE.RenderPass(root.logic.scene, root.logic.camera.camera);\n    //this.passPoster = new THREE.PosterPass(this.size);\n    this.passBloom = new THREE.UnrealBloomPass(this.size, strength, radius, threshold);\n    this.passBloom.renderToScreen = true;\n\n    // composer\n    this.composer = new THREE.EffectComposer(this.renderer);\n    this.composer.addPass(this.passRender);\n    //this.composer.addPass(this.passPoster);\n    this.composer.addPass(this.passBloom);\n\n    // add to dom\n    this.resize();\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n  }\n\n  resize() {\n    this.width = Math.floor(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].width / 100 * window.innerWidth);\n    this.height = Math.floor(_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].height / 100 * window.innerHeight);\n    this.size.x = this.width;\n    this.size.y = this.height;\n    this.renderer.setSize(this.width, this.height);\n    this.composer.setSize(this.width, this.height);\n    this.passBloom.setSize(this.width, this.height);\n  }\n\n  render(delta) {\n    this.composer.render(delta);\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Renderer);\n\n//# sourceURL=webpack://clouds/./js/modules/renderer.js?");

/***/ }),

/***/ "./js/modules/world.js":
/*!*****************************!*\
  !*** ./js/modules/world.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_glsl_SkyShader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/glsl/SkyShader.js */ \"./js/lib/glsl/SkyShader.js\");\n/* harmony import */ var _lib_glsl_SkyShader_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_glsl_SkyShader_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _material_cloud_material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./material/cloud_material */ \"./js/modules/material/cloud_material.js\");\n/* harmony import */ var _ui_hotspot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ui/hotspot */ \"./js/ui/hotspot.js\");\n/* harmony import */ var _portal_handler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./portal_handler */ \"./js/modules/portal_handler.js\");\n/* harmony import */ var _utils_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/loader */ \"./js/utils/loader.js\");\n/* harmony import */ var _overlay_loading_screen__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../overlay/loading_screen */ \"./js/overlay/loading_screen.js\");\n/** Set up and update world */\n\n\n\n\n\n\n\n\nclass World {\n  constructor(root) {\n    this.root = root;\n    this.scene = root.scene;\n    this.camera = root.camera.camera;\n    this.player = root.player;\n    this.domElement = document.querySelector('#canvas-target');\n\n    // load\n    this.loadSky();\n    this.loadModels();\n\n    // lighting\n    const directional = new THREE.DirectionalLight(0xffffff, 1);\n    const ambient = new THREE.AmbientLight(0xffffff, 0.5);\n    directional.position.set(0, 0, 0);\n    directional.target.position.set(0.125, -0.35, 1);\n    this.scene.add(ambient, directional, directional.target);\n\n    // interactive points\n    this.hotspots = [];\n    const hotspot = new _ui_hotspot__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this.scene, this.camera, {\n      position: new THREE.Vector3(0, 0, 10),\n      clickEvent: () => {\n        console.log(\"click!\");\n      }\n    });\n    this.hotspots.push(hotspot);\n\n    // portals\n    this.portals = new _portal_handler__WEBPACK_IMPORTED_MODULE_3__[\"default\"](this.root);\n  }\n\n  loadModels() {\n    const staticAssets = ['floor'];\n    this.loadingScreen = new _overlay_loading_screen__WEBPACK_IMPORTED_MODULE_5__[\"default\"](staticAssets.length);\n    this.loader = new _utils_loader__WEBPACK_IMPORTED_MODULE_4__[\"default\"]('./assets');\n\n    // temp\n    const addToColliderSystem = obj => {\n      if (obj.type == 'Mesh') {\n        this.root.colliderSystem.add(obj);\n      } else if (obj.children && obj.children.length) {\n        obj.children.forEach(child => {\n          addToColliderSystem(child);\n        });\n      }\n    };\n\n    // load assets and add to scene\n    staticAssets.forEach(asset => {\n      this.loader.loadFBX(asset).then(obj => {\n        this.scene.add(obj);\n        this.loadingScreen.onAssetLoaded();\n\n        // temp\n        addToColliderSystem(obj);\n      });\n    });\n  }\n\n  loadSky() {\n    // sky\n    this.sky = new THREE.Sky();\n    this.sky.scale.setScalar(450000);\n    const d = 400000;\n    const azimuth = 0.25;\n    const inclination = 0.495; //0.4875;\n    const theta = Math.PI * (inclination - 0.5);\n    const phi = Math.PI * 2 * (azimuth - 0.5);\n    const sunPos = new THREE.Vector3(d * Math.cos(phi), d * Math.sin(phi) * Math.sin(theta), d * Math.sin(phi) * Math.cos(theta));\n    this.sky.material.uniforms.sunPosition.value.copy(sunPos);\n    this.scene.add(this.sky);\n\n    // clouds\n    this.cloudMat = _material_cloud_material__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n    this.cloudMat.transparent = true;\n    this.cloudMat.uniforms.uTime.value = Math.random() * 60;\n    this.cloudPlane = new THREE.Mesh(new THREE.PlaneBufferGeometry(1500, 2000), this.cloudMat);\n    this.cloudPlane.rotation.x = -Math.PI / 2;\n    this.scene.add(this.cloudPlane);\n  }\n\n  onMouseMove(x, y) {\n    let res = false;\n    for (let i = 0, lim = this.hotspots.length; i < lim; ++i) {\n      this.hotspots[i].onMouseMove(x, y);\n      res = res || this.hotspots[i].hover;\n    }\n\n    if (res) {\n      this.domElement.classList.add('clickable');\n    } else {\n      this.domElement.classList.remove('clickable');\n    }\n  }\n\n  onClick(x, y) {\n    for (let i = 0, lim = this.hotspots.length; i < lim; ++i) {\n      this.hotspots[i].onClick(x, y);\n    }\n  }\n\n  update(delta) {\n    // interaction\n    this.portals.update();\n    for (let i = 0, lim = this.hotspots.length; i < lim; ++i) {\n      this.hotspots[i].update();\n    }\n\n    // clouds\n    this.cloudMat.uniforms.uTime.value += delta;\n    this.cloudPlane.position.copy(this.player.position);\n    this.cloudPlane.position.y -= 50;\n  }\n\n  draw(ctx) {\n    for (let i = 0, lim = this.hotspots.length; i < lim; ++i) {\n      this.hotspots[i].draw(ctx);\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (World);\n\n//# sourceURL=webpack://clouds/./js/modules/world.js?");

/***/ }),

/***/ "./js/overlay/loading_screen.js":
/*!**************************************!*\
  !*** ./js/overlay/loading_screen.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Handle loading screen */\n\nclass LoadingScreen {\n  constructor(toLoad) {\n    this.toLoad = toLoad;\n    this.haveLoaded = 0;\n    this.domElement = document.querySelector('#loading-screen');\n    this.domElementBar = document.querySelector('#loading-screen > .loading-screen__bar');\n  }\n\n  onAssetLoaded() {\n    this.haveLoaded += 1;\n\n    // remove or update loading screen\n    if (this.haveLoaded >= this.toLoad) {\n      this.domElementBar.style.width = '100%';\n      this.domElement.classList.add('fade-out');\n      setTimeout(() => {\n        this.domElement.parentNode.removeChild(this.domElement);\n      }, 1000);\n    } else {\n      const percent = Math.ceil(this.haveLoaded / this.toLoad * 100);\n      this.domElementBar.style.width = `${percent}%`;\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LoadingScreen);\n\n//# sourceURL=webpack://clouds/./js/overlay/loading_screen.js?");

/***/ }),

/***/ "./js/overlay/menu.js":
/*!****************************!*\
  !*** ./js/overlay/menu.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Menu overlay */\n\nclass Menu {\n  constructor() {\n    this.el = {\n      menuButton: document.querySelector('#menu-button'),\n      menu: document.querySelector('#menu')\n    };\n    this.el.menuButton.addEventListener('click', () => {\n      this.toggleMenu();\n    });\n  }\n\n  toggleMenu() {\n    if (this.el.menuButton.classList.contains('active')) {\n      this.el.menuButton.classList.remove('active');\n      this.el.menu.classList.remove('active');\n    } else {\n      this.el.menuButton.classList.add('active');\n      this.el.menu.classList.add('active');\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Menu);\n\n//# sourceURL=webpack://clouds/./js/overlay/menu.js?");

/***/ }),

/***/ "./js/ui/control_surface.js":
/*!**********************************!*\
  !*** ./js/ui/control_surface.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mouse */ \"./js/ui/mouse.js\");\n/* harmony import */ var _keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboard */ \"./js/ui/keyboard.js\");\n/* harmony import */ var _utils_maths__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/maths */ \"./js/utils/maths.js\");\n/** Control surface/ user interface. */\n\n\n\n\n\nclass ControlSurface {\n  constructor(root) {\n    this.logic = root.logic;\n    this.player = root.logic.player;\n    this.domElement = document.querySelector('#canvas-target');\n    this.rect = null;\n    this.centre = { x: 0, y: 0 };\n    this.rotation = new THREE.Vector2();\n    this.timestamp = null;\n    this.threshold = { click: 225, pan: 200, mouseDelta: 0.25 };\n    this.scaleRotation = { x: 1, y: 1 };\n\n    // events\n    this.resize();\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n    this.keyboard = new _keyboard__WEBPACK_IMPORTED_MODULE_1__[\"default\"](key => {\n      this.onKeyboard(key);\n    });\n    this.mouse = new _mouse__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.domElement, e => {\n      this.onMouseDown(e);\n    }, e => {\n      this.onMouseMove(e);\n    }, e => {\n      this.onMouseUp(e);\n    }, this.isMobile);\n  }\n\n  processTouch(e) {\n    let x = 0,\n        y = 0;\n    if (e.targetTouches && e.targetTouches.length) {\n      const rect = this.domElement.getBoundingClientRect();\n      const touch = e.targetTouches[0];\n      x = touch.pageX - rect.left;\n      y = touch.pageY - rect.top;\n    }\n    return { offsetX: x, offsetY: y };\n  }\n\n  onMouseDown(e) {\n    // record player rotation\n    this.rotation.y = this.player.rotation.y;\n    this.rotation.x = this.player.rotation.x;\n    this.timestamp = performance.now();\n    this.mouse.start(e);\n\n    // set cursor position\n    this.onMouseMove(e);\n  }\n\n  onMouseMove(e) {\n    this.mouse.move(e);\n\n    if (this.mouse.active) {\n      // update player rotation\n      if (!(this.player.keys.left || this.player.keys.right)) {\n        const yaw = this.rotation.x + this.mouse.delta.x / this.centre.x * this.scaleRotation.x;\n        const pitch = Object(_utils_maths__WEBPACK_IMPORTED_MODULE_2__[\"Clamp\"])(this.rotation.y + this.mouse.delta.y / this.centre.y * this.scaleRotation.y, this.player.minPitch, this.player.maxPitch);\n        if (pitch == this.player.minPitch || pitch == this.player.maxPitch) {\n          this.mouse.origin.y = e.offsetY;\n          this.rotation.y = pitch;\n        }\n        this.player.setRotation(pitch, yaw);\n      }\n    } else {\n      this.logic.world.onMouseMove(e.clientX - this.rect.left, e.clientY - this.rect.top);\n    }\n  }\n\n  onMouseUp(e) {\n    this.mouse.stop();\n\n    // check for click\n    const now = performance.now();\n    if (now - this.timestamp < this.threshold.click && Math.hypot(this.mouse.delta.x, this.mouse.delta.y) < window.innerWidth * this.threshold.mouseDelta) {\n      this.logic.world.onClick(e.clientX - this.rect.left, e.clientY - this.rect.top);\n      this.timestamp = performance.now();\n    }\n  }\n\n  onKeyboard(key) {\n    switch (key) {\n      case 'a':case 'A':case 'ArrowLeft':\n        this.player.keys.left = this.keyboard.keys[key];\n        break;\n      case 'd':case 'D':case 'ArrowRight':\n        this.player.keys.right = this.keyboard.keys[key];\n        break;\n      case 'w':case 'W':case 'ArrowUp':\n        this.player.keys.up = this.keyboard.keys[key];\n        break;\n      case 's':case 'S':case 'ArrowDown':\n        this.player.keys.down = this.keyboard.keys[key];\n        break;\n      case 'x':case 'X':\n        if (this.keyboard.isControl()) {\n          this.player.noclip = this.player.noclip == false;\n          this.keyboard.release(key);\n        }\n        break;\n      case ' ':\n        this.player.keys.jump = this.keyboard.keys[key];\n        break;\n      default:\n        break;\n    }\n  }\n\n  resize() {\n    this.rect = this.domElement.getBoundingClientRect();\n    this.centre.x = this.rect.width / 2;\n    this.centre.y = this.rect.height / 2;\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ControlSurface);\n\n//# sourceURL=webpack://clouds/./js/ui/control_surface.js?");

/***/ }),

/***/ "./js/ui/hotspot.js":
/*!**************************!*\
  !*** ./js/ui/hotspot.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_screen_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/screen_space */ \"./js/utils/screen_space.js\");\n/* harmony import */ var _raycaster__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./raycaster */ \"./js/ui/raycaster.js\");\n/** Clickable 3D hotspot. */\n\n\n\n\nclass Hotspot {\n  constructor(scene, camera, settings) {\n    this.camera = camera;\n    this.domElement = document.querySelector('#canvas-target');\n    this.screenSpace = new _utils_screen_space__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.camera);\n    this.raycaster = new _raycaster__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.camera);\n    this.hover = false;\n    this.active = false;\n    this.timestamp = null;\n\n    // settings\n    this.position = settings.position || new THREE.Vector3();\n    this.radius = settings.radius || 20;\n    this.clickEvent = settings.clickEvent || (() => {});\n    this.timeout = settings.timeout || 150;\n    this.mesh = settings.mesh || new THREE.Mesh(new THREE.BoxBufferGeometry(1, 1, 1), new THREE.MeshBasicMaterial({ color: 0x000 }));\n    this.mesh.position.copy(this.position);\n    this.mesh.material.visible = false;\n    scene.add(this.mesh);\n\n    // dom\n    this.resize();\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n  }\n\n  resize() {\n    this.rect = this.domElement.getBoundingClientRect();\n  }\n\n  onMouseMove(x, y) {\n    if (this.active) {\n      this.hover = this.raycaster.intersects(x, y, this.mesh);\n    }\n  }\n\n  onClick(x, y) {\n    const now = performance.now();\n    if (this.active && (this.timestamp == null || now - this.timestamp > this.timeout)) {\n      if (this.raycaster.intersects(x, y, this.mesh)) {\n        this.clickEvent();\n        this.timestamp = now;\n      }\n    }\n  }\n\n  update() {\n    this.active = this.camera.position.distanceTo(this.position) <= this.radius && this.screenSpace.isOnScreen(this.position);\n    this.hover = this.hover && this.active;\n  }\n\n  draw(ctx) {\n    if (this.active) {\n      const coords = this.screenSpace.toScreenSpace(this.position);\n      ctx.strokeStyle = '#fff';\n      ctx.lineWidth = 1;\n      ctx.beginPath();\n      ctx.arc(coords.x, coords.y, this.hover ? 20 : 10, 0, Math.PI * 2, false);\n      ctx.stroke();\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Hotspot);\n\n//# sourceURL=webpack://clouds/./js/ui/hotspot.js?");

/***/ }),

/***/ "./js/ui/keyboard.js":
/*!***************************!*\
  !*** ./js/ui/keyboard.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Keyboard interface.  */\n\nclass Keyboard {\n  constructor(onEvent) {\n    this.keys = {};\n    this.onEvent = onEvent;\n    document.addEventListener('keydown', key => {\n      this.onKeyDown(key);\n    });\n    document.addEventListener('keyup', key => {\n      this.onKeyUp(key);\n    });\n  }\n\n  onKeyDown(key) {\n    this.keys[key.key] = true;\n    this.onEvent(key.key);\n  }\n\n  onKeyUp(key) {\n    this.keys[key.key] = false;\n    this.onEvent(key.key);\n  }\n\n  release(key) {\n    this.keys[key] = false;\n  }\n\n  isSpecial() {\n    return this.keys['Shift'] || this.keys['Control'] || this.keys['Alt'];\n  }\n\n  isControl() {\n    return this.keys['Control'];\n  }\n\n  isShift() {\n    return this.keys['Shift'];\n  }\n\n  isAlt() {\n    return this.keys['Alt'];\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Keyboard);\n\n//# sourceURL=webpack://clouds/./js/ui/keyboard.js?");

/***/ }),

/***/ "./js/ui/mouse.js":
/*!************************!*\
  !*** ./js/ui/mouse.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Mouse interface. */\n\nclass Mouse {\n  constructor(domElement, onDown, onMove, onUp, isMobile) {\n    this.x = 0;\n    this.y = 0;\n    this.origin = { x: 0, y: 0 };\n    this.delta = { x: 0, y: 0 };\n    this.active = false;\n    this.domElement = domElement;\n\n    if (!isMobile) {\n      this.domElement.addEventListener('mousedown', onDown, false);\n      this.domElement.addEventListener('mousemove', onMove, false);\n      this.domElement.addEventListener('mouseup', onUp, false);\n      this.domElement.addEventListener('mouseleave', onUp, false);\n    } else {\n      this.domElement.addEventListener('touchstart', onDown, false);\n      this.domElement.addEventListener('touchmove', onMove, false);\n      this.domElement.addEventListener('touchend', onUp, false);\n    }\n\n    // universal\n    // this.domElement.addEventListener('click', evt => { onMove(evt); }, false);\n  }\n\n  start(e) {\n    this.active = true;\n    this.origin.x = e.offsetX;\n    this.origin.y = e.offsetY;\n  }\n\n  move(e) {\n    this.x = e.offsetX;\n    this.y = e.offsetY;\n    this.delta.x = this.x - this.origin.x;\n    this.delta.y = this.y - this.origin.y;\n  }\n\n  stop() {\n    this.active = false;\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Mouse);\n\n//# sourceURL=webpack://clouds/./js/ui/mouse.js?");

/***/ }),

/***/ "./js/ui/portal.js":
/*!*************************!*\
  !*** ./js/ui/portal.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Teleport player */\n\nclass Portal {\n  constructor(from, to, settings) {\n    // settings\n    this.from = from;\n    this.to = to;\n    this.onTeleport = settings.onTeleport || null;\n    if (settings.showBoxes && settings.scene) {\n      const helper1 = new THREE.Box3Helper(this.from, 0xffffff);\n      const helper2 = new THREE.Box3Helper(this.to, 0xffffff);\n      settings.scene.add(helper1, helper2);\n    }\n\n    // set delta\n    this.delta = new THREE.Vector3();\n    const a = new THREE.Vector3();\n    const b = new THREE.Vector3();\n    this.from.getCenter(a);\n    this.to.getCenter(b);\n    b.sub(a);\n    this.delta.copy(b);\n  }\n\n  teleport(player) {\n    player.position.add(this.delta);\n    player.target.position.add(this.delta);\n\n    if (this.onTeleport) {\n      this.onTeleport();\n    }\n  }\n\n  update(player) {\n    if (this.from.containsPoint(player.position)) {\n      this.teleport(player);\n    }\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Portal);\n\n//# sourceURL=webpack://clouds/./js/ui/portal.js?");

/***/ }),

/***/ "./js/ui/raycaster.js":
/*!****************************!*\
  !*** ./js/ui/raycaster.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Raycaster for 3d mouse interaction. */\n\nclass Raycaster {\n  constructor(camera) {\n    this.domElement = document.querySelector('#canvas-target');\n    this.camera = camera;\n    this.raycaster = new THREE.Raycaster();\n    this.mouse = new THREE.Vector2();\n\n    // dom\n    this.resize();\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n  }\n\n  resize() {\n    this.rect = this.domElement.getBoundingClientRect();\n  }\n\n  intersects(x, y, object) {\n    this.mouse.x = x / this.rect.width * 2 - 1;\n    this.mouse.y = -(y / this.rect.height * 2 - 1);\n    this.raycaster.setFromCamera(this.mouse, this.camera);\n    return this.raycaster.intersectObject(object).length > 0;\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Raycaster);\n\n//# sourceURL=webpack://clouds/./js/ui/raycaster.js?");

/***/ }),

/***/ "./js/utils/loader.js":
/*!****************************!*\
  !*** ./js/utils/loader.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_loaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/loaders */ \"./js/lib/loaders/index.js\");\n/** Load model files */\n\n\n\nclass Loader {\n  constructor(path) {\n    this.path = path + '/';\n    this.materials = {};\n    this.images = {};\n    this.loaderFBX = new THREE.FBXLoader();\n    this.loaderOBJ = new THREE.OBJLoader();\n  }\n\n  loadFBX(file) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.loaderFBX.load(this.path + file + '.fbx', obj => {\n          resolve(obj);\n        });\n      } catch (error) {\n        console.log(error);\n        reject(error);\n      }\n    });\n  }\n\n  loadOBJ(file) {\n    return new Promise((resolve, reject) => {\n      try {\n        this.loaderOBJ.load(this.path + file + '.obj', model => {\n          resolve(model);\n        });\n      } catch (error) {\n        console.log(error);\n        reject(error);\n      }\n    });\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Loader);\n\n//# sourceURL=webpack://clouds/./js/utils/loader.js?");

/***/ }),

/***/ "./js/utils/maths.js":
/*!***************************!*\
  !*** ./js/utils/maths.js ***!
  \***************************/
/*! exports provided: Blend, Clamp, MinAngleBetween */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Blend\", function() { return Blend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Clamp\", function() { return Clamp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MinAngleBetween\", function() { return MinAngleBetween; });\n/** Useful maths. */\n\nconst Blend = (a, b, factor) => {\n  return (b - a) * factor + a;\n};\n\nconst MinAngleBetween = function (a1, a2) {\n  return Math.atan2(Math.sin(a2 - a1), Math.cos(a2 - a1));\n};\n\nconst Clamp = (value, min, max) => {\n  return Math.min(max, Math.max(min, value));\n};\n\n\n\n//# sourceURL=webpack://clouds/./js/utils/maths.js?");

/***/ }),

/***/ "./js/utils/screen_space.js":
/*!**********************************!*\
  !*** ./js/utils/screen_space.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/** Screen space conversion util */\n\nclass ScreenSpace {\n  constructor(camera) {\n    this.camera = camera;\n    this.helper = new THREE.Vector3();\n    this.worldDirection = new THREE.Vector3();\n    this.coords = new THREE.Vector2();\n\n    // dom\n    this.domElement = document.querySelector('#canvas-target');\n    this.resize();\n    window.addEventListener('resize', () => {\n      this.resize();\n    });\n  }\n\n  isOnScreen(p) {\n    this.camera.getWorldDirection(this.worldDirection);\n    this.helper.copy(this.camera.position);\n    this.helper.sub(p);\n    return this.helper.dot(this.worldDirection) <= 0;\n  }\n\n  toScreenSpace(p) {\n    this.helper.copy(p);\n    this.helper.project(this.camera);\n    this.coords.x = (this.helper.x + 1) * this.rect.width / 2;\n    this.coords.y = (-this.helper.y + 1) * this.rect.height / 2;\n    return this.coords;\n  }\n\n  resize() {\n    this.rect = this.domElement.getBoundingClientRect();\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ScreenSpace);\n\n//# sourceURL=webpack://clouds/./js/utils/screen_space.js?");

/***/ })

/******/ });